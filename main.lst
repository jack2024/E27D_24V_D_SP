CCS PCD C Compiler, Version 4.104, 5967               03-¾.¤.-23 14:59

               Filename: D:\jobESP\DC Voltage Monitoring Relay\firmware\DIN RAIL No Crytal\PIC24 CCS Project -24 UN-SP\main.lst

               ROM used: 7166 bytes (64%)
                         Largest free fragment is 4094
               RAM used: 251 (6%) at main() level
                         280 (7%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
0000:  GOTO    18D6
*
0022:  DATA    C6,05,00
0024:  DATA    36,02,00
.................... #include "D:\jobESP\DC Voltage Monitoring Relay\firmware\DIN RAIL No Crytal\PIC24 CCS Project -24 UN\main.h" 
.................... #include <24FJ16GA004.h> 
.................... //////// Standard Header file for the PIC24FJ16GA004 device //////////////// 
.................... #device PIC24FJ16GA004 
.................... #list 
....................  
....................  
.................... //////////////////////////////////////////////////////// 
.................... /* 
.................... #FUSES WDT 
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES PROTECT                //Code not protected from reading 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... //#FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... //#FUSES NOWRT                    //Program memory not write protected 
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... */ 
.................... ///////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... //#FUSES NOWDT                    //No Watch Dog Timer 
....................  
....................  
.................... //#FUSES WDT32                    //Watch Dog Timer uses 1:64 Postscale 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES PROTECT                //Code not protected from reading 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES ICSP1                    //ICD uses PGC1/PGD1 pins 
.................... #FUSES IOL1WAY                  //Allows only one reconfiguration of peripheral pins 
.................... #FUSES WDT        //jj 
.................... #FUSES WINDIS                   //Watch Dog Timer in non-Window mode 
.................... #FUSES WPRES32                 //Watch Dog Timer PreScalar 1:128 
.................... #FUSES WPOSTS16   //jj             //Watch Dog Timer PostScalar 1:32768 
....................  
.................... #FUSES IESO     //jj                //Internal External Switch Over mode enabled 
....................  
.................... //#FUSES FRC_PS                   //Fast RC Oscillator with Post Scaler 
.................... #FUSES NOCKSFSM                 //Clock Switching is disabled, fail Safe clock monitor is disabled 
.................... //#FUSES CKSFSM 
....................  
.................... #FUSES NOOSCIO                  //OSC2 is clock output 
.................... //#FUSES NOPR                     //Pimary oscillaotr disabled 
.................... #FUSES I2C1SELD 
.................... //#FUSES HS 
....................  
.................... #use delay(clock=8000000, oscillator=8000000) 
*
0612:  CP0     W0
0614:  BTSC.B  42.1
0616:  BRA     620
0618:  REPEAT  #F99
061A:  NOP     
061C:  DEC     W0,W0
061E:  BRA     612
0620:  RETURN  
....................  
.................... //#use i2c(Master,Slow,sda=PIN_A0,scl=PIN_A1,force_hw) 
.................... //#use delay(clock=32000000,RESTART_WDT) 
....................  
....................  
.................... //#use delay(clock=20000000) 
....................  
....................  
.................... /* 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES ICSP1                    //ICD uses PGC1/PGD1 pins 
.................... #FUSES IOL1WAY                  //Allows only one reconfiguration of peripheral pins 
.................... #FUSES WINDIS                   //Watch Dog Timer in non-Window mode 
.................... #FUSES WPRES128                 //Watch Dog Timer PreScalar 1:128 
.................... #FUSES WPOSTS8                  //Watch Dog Timer PostScalar 1:128 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... //#FUSES FRC_PS                   //Fast RC Oscillator with Post Scaler 
.................... #FUSES NOCKSFSM                 //Clock Switching is disabled, fail Safe clock monitor is disabled 
.................... #FUSES NOOSCIO                  //OSC2 is clock output 
.................... #FUSES HS                       //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES I2C1SELD               
....................  
.................... #use delay(clock=8000000,RESTART_WDT) 
.................... */ 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1938:  CLR     800
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define UnderSet_addr 0x00 
.................... #define OverSet_addr 0x01 
.................... #define UnderResSet_addr 0x02 
.................... #define OverResSet_addr 0x03 
.................... #define UnderTimSet_addr 0x04 
.................... #define OverTimSet_addr 0x05 
.................... #define UnderResTimSet_addr 0x06 
.................... #define OverResTimSet_addr 0x07 
....................  
.................... int1 FlashLEDUnder = false; 
.................... int1 FlashLEDOver = false; 
....................  
.................... volatile unsigned int8 flash_LED_Under =0,flash_LED_Over =0; 
....................  
.................... volatile int8 toggle_pin_under =0; 
.................... volatile int8 toggle_pin_over =0; 
....................  
.................... // Update 18/5/63 Right 
.................... #define LED_Healty PIN_B5 
.................... #define LED_Under PIN_B4 
.................... #define LED_Over  PIN_B0 
....................  
.................... #define Over_Rly PIN_B7 
.................... #define Under_Rly PIN_B6 
....................  
.................... #define HIGH  1 
.................... #define LOW   0 
....................  
.................... //   for din rail 
.................... #define BT_DW PIN_B13 
.................... #define BT_UP PIN_B14 
.................... #define BT_SET PIN_B15 
....................  
.................... //   for surface mount 
.................... //#define BT_DW PIN_B14 
.................... //#define BT_UP PIN_B15 
.................... //#define BT_SET PIN_B13 
....................  
.................... #define EXP_OUT_DO      PIN_B12 
.................... #define EXP_OUT_CLOCK   PIN_B11 
.................... #define EXP_OUT_ENABLE  PIN_B10 
....................  
.................... #define EEPROM_SDA  PIN_B9 
.................... #define EEPROM_SCL  PIN_B8 
....................  
.................... //#use i2c(Master,slow,sda=PIN_B9,scl=PIN_B8, stream=MCP342X_STREAM, FORCE_HW)// 
.................... //#use i2c(Master, fast=450000,sda=PIN_B9,scl=PIN_B8, stream=MCP342X_STREAM, FORCE_SW) 
.................... //#use i2c(Master,slow,sda=PIN_B9,scl=PIN_B8, stream=MCP342X_STREAM) 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_B4,rcv=PIN_B5,bits=8) 
.................... //#use i2c(Master,sda=PIN_B9,scl=PIN_B8, stream=MCP342X_STREAM,restart_wdt) 
....................  
.................... #define NORMAL_VOLT 24 
.................... #define MAX_VOLT 35 
.................... #define MIN_VOLT 15 
.................... #define MAX_TIME 60 
.................... #define MIN_TIME 0 
....................  
.................... volatile unsigned int16 DC_V; 
.................... volatile int16 DC_V7seg; 
.................... int16 DC_Average[12]; 
.................... boolean set_mode = false; 
.................... volatile unsigned int32 menuCount; 
.................... volatile signed char flash_dot,flash_LED; 
....................  
.................... volatile unsigned int8 DebugLoopCount =0; 
....................  
.................... volatile unsigned int8 HangCount =0,oldloop =0,Updateloop =1; 
....................  
.................... volatile unsigned int8 ReadI2CCount =0,I2C_wait; 
....................  
.................... volatile int1 Ack1 =1,Ack2 =1,Ack3 =1; 
....................  
....................  
.................... int16 real_data ; 
....................  
.................... float vout = 0.0; 
.................... float vin = 0.0; 
....................  
.................... //float VbuffArray[22]; 
....................  
.................... //float R1 = 100000.0; // resistance of R1 (100K) 220 
.................... //float R1 = 56000.0; // resistance of R1 (100K) -125 
.................... float R1 = 10000.0; 
.................... float R2 =    680.0; // resistance of R2 (100) - see text! 
....................  
.................... //#use i2c(Master,sda=I2C_SDA,scl=I2C_SCL) 
....................  
.................... unsigned char roi, sib, hnoi; 
....................  
.................... /* Segment byte maps for numbers 0 to 9 */ 
.................... const unsigned char SEGMENT_MAP[] = {0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90}; 
.................... /* Byte maps to select digit 1 to 4 */ 
.................... const unsigned char SEGMENT_SELECT[] = {0xFE,0xFD,0xFB,0xF7}; 
....................  
.................... //const byte CHR[] ={0xAA, 0xA3,}; 
.................... enum{State_nor,State_PreUnder,State_Under,State_PreUnderRes,State_UnderRes,State_PreOver,State_Over,State_PreOverRes,State_OverRes}; 
....................  
.................... // UNDER OVER 
.................... enum{nor, UnderSet, OverSet,UnderResSet,OverResSet,UnderTimSet,OverTimSet,UnderResTimSet,OverResTimSet}; 
.................... // UNDER Only 
.................... enum{Nor_UnOly, UnderSet_UnOly, UnderResSet_UnOly, UnderTimSet_UnOly, UnderResTimSet_UnOly}; 
....................  
.................... volatile unsigned int8 mode = Nor_UnOly,State = State_nor; 
.................... volatile signed int16 UnderResTimeCount=0 ,OverResTimeCount=0, UnderTimeCount=0, OverTimeCount =0; 
.................... volatile signed int16  OverTimSetValue,UnderResTimSetValue, UnderTimSetValue, OverResTimSetValue; 
.................... volatile float UnderValue, OverValue, UnderResValue, OverResValue; 
.................... volatile signed int16 StartMeasureCount = 600; 
....................  
.................... volatile unsigned int8 TIMER_Flag =0; 
....................  
.................... #define MCP342X_CONTINUOUS 0x10 
.................... #define MCP342X_ONE_SHOT   0x00 
....................  
.................... #define MCP342X_18BITS     0x0C 
.................... #define MCP342X_16BITS     0x08 
.................... #define MCP342X_14BITS     0x04 
.................... #define MCP342X_12BITS     0x00 
....................  
.................... #define MCP342X_8X_GAIN    0x03 
.................... #define MCP342X_4X_GAIN    0x02 
.................... #define MCP342X_2X_GAIN    0x01 
.................... #define MCP342X_1X_GAIN    0x00 
....................  
.................... #define MCP342X_DEVICE_CODE       0xD0 
.................... #define MCP342X_START_CONVERSTION 0x80 
....................  
.................... #define MCP342X_GENERAL_CALL_ADDRESS   0x00 
.................... #define MCP342X_GENERAL_CALL_LATCH     0x04 
....................  
.................... #define MCP342X_MODE MCP342X_CONTINUOUS 
.................... #ifndef MCP342X_MODE 
....................  #define MCP342X_MODE MCP342X_ONE_SHOT 
.................... #endif 
....................  
.................... #define MCP342X_BITS MCP342X_16BITS 
.................... #ifndef MCP342X_BITS 
....................  #define MCP342X_BITS MCP342X_16BITS 
.................... #endif 
....................  
.................... #define MCP342X_GAIN MCP342X_1X_GAIN 
.................... #ifndef MCP342X_GAIN 
....................  #define MCP342X_GAIN MCP342X_1X_GAIN 
.................... #endif 
....................  
.................... #define MCP342X_ADDRESS 0 
.................... #ifndef MCP342X_ADDRESS 
....................  #define MCP342X_ADDRESS 0 
.................... #endif 
....................  
.................... #define MCP342X_CHANNEL 0 
.................... #ifndef MCP342X_CHANNEL 
....................  #define MCP342X_CHANNEL 0 
.................... #endif 
....................  
.................... /********************************************************** 
....................  
.................... Software I2C Library for PIC24 Devices. 
....................  
.................... **********************************************************/ 
.................... #define MCP342X_SCL  PIN_B8 
.................... #define MCP342X_SDA  PIN_B9 
....................  
.................... void SoftI2CInit() 
.................... { 
....................    SET_TRIS_B( 0xE000 );// SDA SCL OUTPUT  
*
0622:  MOV     #E000,W4
0624:  MOV     W4,2C8
....................    output_high(MCP342X_SCL); 
0626:  BCLR.B  2C9.0
0628:  BSET.B  2CD.0
....................    output_high(MCP342X_SDA);      
062A:  BCLR.B  2C9.1
062C:  BSET.B  2CD.1
.................... } 
062E:  RETURN  
....................  
.................... void i2cNack(void) 
.................... { 
....................    output_high(MCP342X_SDA); 
*
0B24:  BCLR.B  2C9.1
0B26:  BSET.B  2CD.1
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B28:  REPEAT  #3
0B2A:  NOP     
....................    output_high(MCP342X_SCL); 
0B2C:  BCLR.B  2C9.0
0B2E:  BSET.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B30:  REPEAT  #3
0B32:  NOP     
....................    output_low(MCP342X_SCL); 
0B34:  BCLR.B  2C9.0
0B36:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B38:  REPEAT  #3
0B3A:  NOP     
....................    output_high(MCP342X_SCL); 
0B3C:  BCLR.B  2C9.0
0B3E:  BSET.B  2CD.0
.................... } 
0B40:  RETURN  
.................... void i2cAck(void) 
.................... { 
....................    output_low(MCP342X_SDA); 
*
0B06:  BCLR.B  2C9.1
0B08:  BCLR.B  2CD.1
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B0A:  REPEAT  #3
0B0C:  NOP     
....................    output_high(MCP342X_SCL); 
0B0E:  BCLR.B  2C9.0
0B10:  BSET.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B12:  REPEAT  #3
0B14:  NOP     
....................    output_low(MCP342X_SCL); 
0B16:  BCLR.B  2C9.0
0B18:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0B1A:  REPEAT  #3
0B1C:  NOP     
....................    output_high(MCP342X_SCL); 
0B1E:  BCLR.B  2C9.0
0B20:  BSET.B  2CD.0
.................... } 
0B22:  RETURN  
.................... void SoftI2CStart() 
.................... { 
....................    output_high(MCP342X_SCL); 
*
0630:  BCLR.B  2C9.0
0632:  BSET.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0634:  REPEAT  #3
0636:  NOP     
....................     
....................    output_low(MCP342X_SDA); 
0638:  BCLR.B  2C9.1
063A:  BCLR.B  2CD.1
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
063C:  REPEAT  #3
063E:  NOP     
....................     
....................    //   Add by  jj 
....................    output_low(MCP342X_SCL); 
0640:  BCLR.B  2C9.0
0642:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0644:  REPEAT  #3
0646:  NOP     
.................... } 
0648:  RETURN  
.................... void SoftI2CStop() 
.................... { 
....................     output_low(MCP342X_SDA); 
*
06AC:  BCLR.B  2C9.1
06AE:  BCLR.B  2CD.1
....................     delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
06B0:  REPEAT  #3
06B2:  NOP     
....................     output_high(MCP342X_SCL); 
06B4:  BCLR.B  2C9.0
06B6:  BSET.B  2CD.0
....................     delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
06B8:  REPEAT  #3
06BA:  NOP     
....................     output_high(MCP342X_SDA); 
06BC:  BCLR.B  2C9.1
06BE:  BSET.B  2CD.1
....................     delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
06C0:  REPEAT  #3
06C2:  NOP     
.................... } 
06C4:  RETURN  
.................... unsigned int8 SoftI2CWriteByte(unsigned int8 data) 
.................... { 
....................     unsigned int8 i; 
....................         
....................     for(i=0;i<8;i++) 
*
064A:  CLR.B   87D
064C:  MOV     87C,W4
064E:  LSR     W4,#8,W4
0650:  CP.B    W4L,#8
0652:  BRA     C,67C
....................     { 
....................       output_low(MCP342X_SCL); 
0654:  BCLR.B  2C9.0
0656:  BCLR.B  2CD.0
....................       delay_cycles( 5 ); // 1 microsec @ 32 Mhz     
0658:  REPEAT  #3
065A:  NOP     
....................       if(data & 0x80) 
065C:  BTSS.B  87C.7
065E:  BRA     666
....................          output_high(MCP342X_SDA); 
0660:  BCLR.B  2C9.1
0662:  BSET.B  2CD.1
....................       else 
0664:  BRA     66A
....................          output_low(MCP342X_SDA); 
0666:  BCLR.B  2C9.1
0668:  BCLR.B  2CD.1
....................       delay_cycles( 5 ); // 1 microsec @ 32 Mhz     
066A:  REPEAT  #3
066C:  NOP     
....................       output_high(MCP342X_SCL); 
066E:  BCLR.B  2C9.0
0670:  BSET.B  2CD.0
....................       delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0672:  REPEAT  #3
0674:  NOP     
....................        
....................       data=data<<1; 
0676:  SL.B    87C
....................    }  
0678:  INC.B   087D
067A:  BRA     64C
....................    //The 9th clock (ACK Phase) 
....................    output_low(MCP342X_SCL); 
067C:  BCLR.B  2C9.0
067E:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0680:  REPEAT  #3
0682:  NOP     
....................  
....................    //Stay hight wait for slave clear(low) signal to ack. 
....................    output_float (MCP342X_SDA);//SDA Input 
0684:  BSET.B  2C9.1
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0686:  REPEAT  #3
0688:  NOP     
....................        
....................    output_high(MCP342X_SCL); 
068A:  BCLR.B  2C9.0
068C:  BSET.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
068E:  REPEAT  #3
0690:  NOP     
....................     
....................    //#**** Read Ack bit from Slave ****#// 
....................    //SET_TRIS_B( 0xE200 ); //SDA Input 
....................    unsigned int8 ack = input(MCP342X_SDA); 
0692:  BSET.B  2C9.1
....................    SET_TRIS_B( 0xE000 ); //SDA Output 
*
069A:  MOV     #E000,W4
069C:  MOV     W4,2C8
....................     
....................    output_low(MCP342X_SCL); 
069E:  BCLR.B  2C9.0
06A0:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
06A2:  REPEAT  #3
06A4:  NOP     
....................     
....................    return ack;   
06A6:  MOV.B   87E,W0L
06A8:  MOV.B   W0L,0
.................... } 
06AA:  RETURN  
....................  
.................... unsigned char i2cReadByte(void) 
.................... { 
*
0ABC:  MOV     W5,[W15++]
....................    unsigned char inByte, n; 
....................    SET_TRIS_B( 0xE200 ); // SET SDA Input 
0ABE:  MOV     #E200,W4
0AC0:  MOV     W4,2C8
....................     
....................    // Add By jj 
....................    output_low(MCP342X_SCL); 
0AC2:  BCLR.B  2C9.0
0AC4:  BCLR.B  2CD.0
....................    delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0AC6:  REPEAT  #3
0AC8:  NOP     
....................       
....................    for (n=0; n<8; n++) 
0ACA:  CLR.B   87D
0ACC:  MOV     87C,W4
0ACE:  LSR     W4,#8,W4
0AD0:  CP.B    W4L,#8
0AD2:  BRA     C,AFA
....................    { 
....................      output_high(MCP342X_SCL); 
0AD4:  BCLR.B  2C9.0
0AD6:  BSET.B  2CD.0
....................      delay_cycles( 5 ); // 1 microsec @ 32 Mhz 
0AD8:  REPEAT  #3
0ADA:  NOP     
....................       
....................      if(input(MCP342X_SDA)) 
0ADC:  BSET.B  2C9.1
0ADE:  BTSS.B  2CB.1
0AE0:  BRA     AEC
....................       inByte = (inByte << 1) | 0x01; // msbit first 
0AE2:  MOV.B   87C,W0L
0AE4:  SL      W0,#1,W0
0AE6:  IOR.B    W0L,  #1,W0L
0AE8:  MOV.B   W0L,87C
....................      else 
0AEA:  BRA     AEE
....................       inByte = inByte << 1; 
0AEC:  SL.B    87C
....................       
....................      output_low(MCP342X_SCL); 
0AEE:  BCLR.B  2C9.0
0AF0:  BCLR.B  2CD.0
....................      delay_cycles( 5 ); // 1 microsec @ 32 Mhz   
0AF2:  REPEAT  #3
0AF4:  NOP     
....................    } 
0AF6:  INC.B   087D
0AF8:  BRA     ACC
....................    SET_TRIS_B( 0xE000 ); // SET SDA Output 
0AFA:  MOV     #E000,W4
0AFC:  MOV     W4,2C8
....................    return(inByte); 
0AFE:  MOV.B   87C,W0L
0B00:  MOV.B   W0L,0
.................... } 
0B02:  MOV     [--W15],W5
0B04:  RETURN  
....................  
.................... // MCP3425 Initial 
.................... void Soft_adc_init() 
.................... { 
....................   SoftI2CInit(); 
*
06C6:  CALL    622
....................    
....................   SoftI2CStart(); 
06CA:  CALL    630
....................   Ack1 = SoftI2CWriteByte(MCP342X_DEVICE_CODE | (MCP342X_ADDRESS << 1));  //send write command 
06CE:  MOV.B   #D0,W0L
06D0:  MOV.B   W0L,87C
06D2:  CALL    64A
06D6:  BCLR.B  802.3
06D8:  BTSC.B  0.0
06DA:  BSET.B  802.3
....................   Ack2 = SoftI2CWriteByte (MCP342X_MODE | MCP342X_BITS | MCP342X_GAIN | (MCP342X_CHANNEL << 5));  //send device configuration 
06DC:  MOV.B   #18,W0L
06DE:  MOV.B   W0L,87C
06E0:  CALL    64A
06E4:  BCLR.B  802.4
06E6:  BTSC.B  0.0
06E8:  BSET.B  802.4
....................   SoftI2CStop(); 
06EA:  CALL    6AC
.................... } 
06EE:  RETURN  
....................  
.................... // MCP3425 Read ADC 16 bit  Total 104 uSec. time Operate 
.................... signed int16 Soft_read_adc_mcp(void) 
.................... { 
*
0B42:  MOV.B   #80,W0L
0B44:  MOV.B   W0L,87A
....................   union 
....................   { 
....................     signed int16 sint16; 
....................     unsigned int8 b[2]; 
....................   } result; 
....................   unsigned int8 status = 0x80; 
....................    
....................   SoftI2CStart(); 
0B46:  CALL    630
....................   Ack1 = SoftI2CWriteByte(MCP342X_DEVICE_CODE | (MCP342X_ADDRESS << 1) | 1);  //send read command 
0B4A:  MOV.B   #D1,W0L
0B4C:  MOV.B   W0L,87C
0B4E:  CALL    64A
0B52:  BCLR.B  802.3
0B54:  BTSC.B  0.0
0B56:  BSET.B  802.3
....................   result.b[1] = i2cReadByte(); 
0B58:  CALL    ABC
0B5C:  MOV.B   W0L,879
....................   i2cAck(); 
0B5E:  CALL    B06
....................   result.b[0] = i2cReadByte(); 
0B62:  CALL    ABC
0B66:  MOV.B   W0L,878
....................   i2cAck(); 
0B68:  CALL    B06
....................   status = i2cReadByte(); 
0B6C:  CALL    ABC
0B70:  MOV.B   W0L,87A
....................   i2cNack(); 
0B72:  CALL    B24
....................   SoftI2CStop(); 
0B76:  CALL    6AC
....................    
....................   return(result.sint16); 
0B7A:  PUSH    878
0B7C:  POP     0
.................... } 
0B7E:  RETURN  
....................  
.................... // END Software I2C Library 
....................  
.................... /*============EEPROM==========================*/ 
....................  
.................... #use i2c(Master,Slow,sda=PIN_A0,scl=PIN_A1,restart_wdt,force_hw) 
*
06F0:  MOV     #8,W2
06F2:  CLRWDT  
06F4:  REPEAT  #0
06F6:  NOP     
06F8:  BCLR.B  2C4.1
06FA:  BCLR.B  2C0.1
06FC:  CLRWDT  
06FE:  REPEAT  #1
0700:  NOP     
0702:  RLC.B   W1L,W1L
0704:  BCLR.B  2C4.0
0706:  BTSC.B  42.0
0708:  BSET.B  2C0.0
070A:  BTSS.B  42.0
070C:  BCLR.B  2C0.0
070E:  BSET.B  2C0.1
0710:  BTSS.B  2C2.1
0712:  BRA     710
0714:  DEC     W2,W2
0716:  BRA     NZ,6F2
0718:  CLRWDT  
071A:  REPEAT  #0
071C:  NOP     
071E:  BCLR.B  2C4.1
0720:  BCLR.B  2C0.1
0722:  NOP     
0724:  BSET.B  2C0.0
0726:  CLRWDT  
0728:  REPEAT  #1
072A:  NOP     
072C:  CLRWDT  
072E:  REPEAT  #1
0730:  NOP     
0732:  BSET.B  2C0.1
0734:  BTSS.B  2C2.1
0736:  BRA     734
0738:  CLRWDT  
073A:  REPEAT  #1
073C:  NOP     
073E:  MOV     #0,W0
0740:  BTSC.B  2C2.0
0742:  BSET    W0.0
0744:  BCLR.B  2C4.1
0746:  BCLR.B  2C0.1
0748:  BCLR.B  2C4.0
074A:  BCLR.B  2C0.0
074C:  RETURN  
*
079C:  MOV     #8,W3
079E:  BSET.B  2C0.0
07A0:  CLRWDT  
07A2:  REPEAT  #1
07A4:  NOP     
07A6:  BSET.B  2C0.1
07A8:  BTSS.B  2C2.1
07AA:  BRA     7A8
07AC:  BTSC.B  2C2.0
07AE:  BSET.B  42.0
07B0:  BTSS.B  2C2.0
07B2:  BCLR.B  42.0
07B4:  RLC     W2,W2
07B6:  CLRWDT  
07B8:  REPEAT  #0
07BA:  NOP     
07BC:  BCLR.B  2C0.1
07BE:  BCLR.B  2C4.1
07C0:  DEC     W3,W3
07C2:  BRA     NZ,79E
07C4:  BSET.B  2C0.0
07C6:  CLRWDT  
07C8:  REPEAT  #1
07CA:  NOP     
07CC:  BCLR.B  2C4.0
07CE:  CP0     W1
07D0:  BTSS.B  42.1
07D2:  BCLR.B  2C0.0
07D4:  NOP     
07D6:  BSET.B  2C0.1
07D8:  BTSS.B  2C2.1
07DA:  BRA     7D8
07DC:  CLRWDT  
07DE:  REPEAT  #0
07E0:  NOP     
07E2:  BCLR.B  2C4.1
07E4:  BCLR.B  2C0.1
07E6:  CLRWDT  
07E8:  REPEAT  #1
07EA:  NOP     
07EC:  BCLR.B  2C4.0
07EE:  BCLR.B  2C0.0
07F0:  MOV     W2,W0
07F2:  RETURN  
.................... #define EEPROM_ADDRESS BYTE 
.................... #define EEPROM_SIZE    128 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
....................    output_float(EEPROM_SDA); 
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
074E:  BSET.B  2C0.0
0750:  CLRWDT  
0752:  REPEAT  #0
0754:  NOP     
0756:  BSET.B  2C0.1
0758:  CLRWDT  
075A:  REPEAT  #1
075C:  NOP     
075E:  BCLR.B  2C4.0
0760:  BCLR.B  2C0.0
0762:  CLRWDT  
0764:  REPEAT  #0
0766:  NOP     
0768:  BCLR.B  2C4.1
076A:  BCLR.B  2C0.1
....................    ack = i2c_write(0xa0);  // then the device is ready. 
076C:  MOV.B   #A0,W1L
076E:  CALL    6F0
0772:  BCLR.B  87E.0
0774:  BTSC.B  0.0
0776:  BSET.B  87E.0
....................    i2c_stop(); 
0778:  BCLR.B  2C0.0
077A:  NOP     
077C:  BSET.B  2C0.1
077E:  BTSS.B  2C2.1
0780:  BRA     77E
0782:  CLRWDT  
0784:  REPEAT  #0
0786:  NOP     
0788:  REPEAT  #1
078A:  NOP     
078C:  BSET.B  2C0.0
078E:  CLRWDT  
0790:  REPEAT  #0
0792:  NOP     
....................    return !ack; 
0794:  CLR.B   W0
0796:  BTSS.B  87E.0
0798:  INC     W0,W0
.................... } 
079A:  RETURN  
....................  
.................... void write_ext_eeprom(BYTE address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
*
0F08:  CALL    74E
0F0C:  CP0.B   W0L
0F0E:  BRA     Z,F08
....................    i2c_start(); 
0F10:  BSET.B  2C0.0
0F12:  CLRWDT  
0F14:  REPEAT  #0
0F16:  NOP     
0F18:  BSET.B  2C0.1
0F1A:  CLRWDT  
0F1C:  REPEAT  #1
0F1E:  NOP     
0F20:  BCLR.B  2C4.0
0F22:  BCLR.B  2C0.0
0F24:  CLRWDT  
0F26:  REPEAT  #0
0F28:  NOP     
0F2A:  BCLR.B  2C4.1
0F2C:  BCLR.B  2C0.1
....................    i2c_write(0xa0); 
0F2E:  MOV.B   #A0,W1L
0F30:  CALL    6F0
....................    i2c_write(address); 
0F34:  MOV     87A,W1
0F36:  CALL    6F0
....................    i2c_write(data); 
0F3A:  MOV.B   87B,W0L
0F3C:  MOV     W0,W1
0F3E:  CALL    6F0
....................    i2c_stop(); 
0F42:  BCLR.B  2C0.0
0F44:  NOP     
0F46:  BSET.B  2C0.1
0F48:  BTSS.B  2C2.1
0F4A:  BRA     F48
0F4C:  CLRWDT  
0F4E:  REPEAT  #0
0F50:  NOP     
0F52:  REPEAT  #1
0F54:  NOP     
0F56:  BSET.B  2C0.0
0F58:  CLRWDT  
0F5A:  REPEAT  #0
0F5C:  NOP     
.................... } 
0F5E:  RETURN  
....................  
.................... BYTE read_ext_eeprom(BYTE address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
*
07F4:  CALL    74E
07F8:  CP0.B   W0L
07FA:  BRA     Z,7F4
....................    i2c_start(); 
07FC:  BSET.B  2C0.0
07FE:  CLRWDT  
0800:  REPEAT  #0
0802:  NOP     
0804:  BSET.B  2C0.1
0806:  CLRWDT  
0808:  REPEAT  #1
080A:  NOP     
080C:  BCLR.B  2C4.0
080E:  BCLR.B  2C0.0
0810:  CLRWDT  
0812:  REPEAT  #0
0814:  NOP     
0816:  BCLR.B  2C4.1
0818:  BCLR.B  2C0.1
....................    i2c_write(0xa0); 
081A:  MOV.B   #A0,W1L
081C:  CALL    6F0
....................    i2c_write(address); 
0820:  MOV     876,W1
0822:  CALL    6F0
....................    i2c_start(); 
0826:  BSET.B  2C0.0
0828:  CLRWDT  
082A:  REPEAT  #0
082C:  NOP     
082E:  BSET.B  2C0.1
0830:  CLRWDT  
0832:  REPEAT  #1
0834:  NOP     
0836:  BTSS.B  2C2.1
0838:  BRA     836
083A:  BCLR.B  2C4.0
083C:  BCLR.B  2C0.0
083E:  CLRWDT  
0840:  REPEAT  #0
0842:  NOP     
0844:  BCLR.B  2C4.1
0846:  BCLR.B  2C0.1
....................    i2c_write(0xa1); 
0848:  MOV.B   #A1,W1L
084A:  CALL    6F0
....................    data=i2c_read(0); 
084E:  MOV     #0,W1
0850:  MOV     W1,[W15++]
0852:  MOV     [--W15],W1
0854:  CALL    79C
0858:  MOV.B   W0L,877
....................    i2c_stop(); 
085A:  BCLR.B  2C0.0
085C:  NOP     
085E:  BSET.B  2C0.1
0860:  BTSS.B  2C2.1
0862:  BRA     860
0864:  CLRWDT  
0866:  REPEAT  #0
0868:  NOP     
086A:  REPEAT  #1
086C:  NOP     
086E:  BSET.B  2C0.0
0870:  CLRWDT  
0872:  REPEAT  #0
0874:  NOP     
....................    return(data); 
0876:  MOV.B   877,W0L
.................... } 
0878:  RETURN  
.................... //////////////////////////////////////////////////// 
.................... void delay_nanosec(int16 us) { //about 800 nanosec 
....................    volatile int16 counter = us; 
....................    while(counter--); 
.................... } 
....................  
.................... ////////////////////////////////////// 
.................... void EEPROM_WriteFloat(float value, int address) { 
....................    unsigned char *p = (unsigned char *)&value; 
....................    int i; 
....................    for(i = 0; i < sizeof(float); i++) { 
....................       write_ext_eeprom(address + i, *p); 
....................       p++; 
....................    } 
.................... } 
....................  
.................... ////////////////////////////////// 
.................... float EEPROM_ReadFloat(int address) { 
....................    float value; 
....................    unsigned char *p = (unsigned char *)&value; 
....................    int i; 
....................    for(i = 0; i < sizeof(float); i++) { 
....................       *p = read_ext_eeprom(address + i); 
....................       p++; 
....................    } 
....................    return value; 
.................... } 
....................  
.................... /********************************6B595 Driver*********************************/ 
.................... void SegmentDisplay() 
.................... { 
*
0346:  CLR.B   894
....................   Signed int8 j=0,data_out,data_U2,data_U1; 
....................   static int8 cnt=0 ; 
....................    
....................     //+++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
....................   static int V_to_Seg;  
*
193A:  CLR     86A
....................   if(mode == nor)   
*
0348:  CP0.B   844
034A:  BRA     NZ,352
....................    V_to_Seg = DC_V7seg; 
034C:  PUSH    80A
034E:  POP     86A
....................   else if(mode == UnderSet) 
0350:  BRA     3C8
0352:  MOV     844,W4
0354:  CP.B    W4L,#1
0356:  BRA     NZ,364
....................    V_to_Seg = UnderValue; 
0358:  MOV     856,W0
035A:  MOV     858,W1
035C:  CALL    31A
0360:  MOV     W0,86A
....................   else if(mode == OverSet) 
0362:  BRA     3C8
0364:  MOV     844,W4
0366:  CP.B    W4L,#2
0368:  BRA     NZ,376
....................    V_to_Seg = OverValue; 
036A:  MOV     85A,W0
036C:  MOV     85C,W1
036E:  CALL    31A
0372:  MOV     W0,86A
....................   else if(mode == UnderResSet) 
0374:  BRA     3C8
0376:  MOV     844,W4
0378:  CP.B    W4L,#3
037A:  BRA     NZ,388
....................    V_to_Seg = UnderResValue; 
037C:  MOV     85E,W0
037E:  MOV     860,W1
0380:  CALL    31A
0384:  MOV     W0,86A
....................   else if(mode == OverResSet) 
0386:  BRA     3C8
0388:  MOV     844,W4
038A:  CP.B    W4L,#4
038C:  BRA     NZ,39A
....................    V_to_Seg = OverResValue; 
038E:  MOV     862,W0
0390:  MOV     864,W1
0392:  CALL    31A
0396:  MOV     W0,86A
....................   else if(mode == UnderTimSet) 
0398:  BRA     3C8
039A:  MOV     844,W4
039C:  CP.B    W4L,#5
039E:  BRA     NZ,3A6
....................    V_to_Seg = UnderTimSetValue; 
03A0:  PUSH    852
03A2:  POP     86A
....................   else if(mode == OverTimSet) 
03A4:  BRA     3C8
03A6:  MOV     844,W4
03A8:  CP.B    W4L,#6
03AA:  BRA     NZ,3B2
....................    V_to_Seg = OverTimSetValue; 
03AC:  PUSH    84E
03AE:  POP     86A
....................   else if(mode == UnderResTimSet) 
03B0:  BRA     3C8
03B2:  MOV     844,W4
03B4:  CP.B    W4L,#7
03B6:  BRA     NZ,3BE
....................    V_to_Seg = UnderResTimSetValue; 
03B8:  PUSH    850
03BA:  POP     86A
....................   else if(mode == OverResTimSet) 
03BC:  BRA     3C8
03BE:  MOV     844,W4
03C0:  CP.B    W4L,#8
03C2:  BRA     NZ,3C8
....................    V_to_Seg = OverResTimSetValue; 
03C4:  PUSH    854
03C6:  POP     86A
....................    
....................   //  ========== Hold Display Show ================  
....................   static int16 Count_Display = 7; //7*62 = 434ms 
....................   if(--Count_Display <= 0) 
03C8:  DEC     086C
03CA:  MOV     86C,W4
03CC:  CP      W4,#0
03CE:  BRA     GT,402
....................   { 
....................      Count_Display = 7;     
03D0:  MOV     #7,W4
03D2:  MOV     W4,86C
....................      roi = V_to_Seg/100; 
03D4:  MOV     86A,W4
03D6:  MOV     #64,W3
03D8:  REPEAT  #11
03DA:  DIV.S   W4,W3
03DC:  MOV.B   W0L,82F
....................      sib = V_to_Seg%100; 
03DE:  MOV     86A,W4
03E0:  MOV     #64,W3
03E2:  REPEAT  #11
03E4:  DIV.S   W4,W3
03E6:  MOV     W1,W0
03E8:  MOV.B   W0L,842
....................      sib = sib/10;    
03EA:  MOV     842,W4
03EC:  CLR.B   9
03EE:  MOV     #A,W3
03F0:  REPEAT  #11
03F2:  DIV.U   W4,W3
03F4:  MOV.B   W0L,842
....................      hnoi = V_to_Seg%10; 
03F6:  MOV     86A,W4
03F8:  MOV     #A,W3
03FA:  REPEAT  #11
03FC:  DIV.S   W4,W3
03FE:  MOV     W1,W0
0400:  MOV.B   W0L,843
....................   } 
....................     
....................    //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
....................    //restart_wdt(); 
....................    if(++cnt > 2)cnt = 0; 
0402:  INC.B   0869
0404:  MOV     868,W4
0406:  LSR     W4,#8,W4
0408:  CP.B    W4L,#2
040A:  BRA     LE,40E
040C:  CLR.B   869
....................    switch(cnt) 
....................    {       
040E:  MOV.B   869,W0L
0410:  CLR.B   1
0412:  XOR     #0,W0
0414:  BRA     Z,420
0416:  XOR     #1,W0
0418:  BRA     Z,42A
041A:  XOR     #3,W0
041C:  BRA     Z,434
041E:  BRA     43E
....................      case 0: // --1  
....................       data_U2 = hnoi; 
0420:  MOV.B   843,W0L
0422:  MOV.B   W0L,896
....................       data_U1 = cnt; 
0424:  MOV.B   869,W0L
0426:  MOV.B   W0L,897
....................      break; 
0428:  BRA     43E
....................  
....................      case 1: //--2 
....................        data_U2 = sib; 
042A:  MOV.B   842,W0L
042C:  MOV.B   W0L,896
....................        data_U1 = cnt; 
042E:  MOV.B   869,W0L
0430:  MOV.B   W0L,897
....................      break; 
0432:  BRA     43E
....................        
....................      case 2: // --3 
....................        data_U2 = roi; 
0434:  MOV.B   82F,W0L
0436:  MOV.B   W0L,896
....................        data_U1 = cnt; 
0438:  MOV.B   869,W0L
043A:  MOV.B   W0L,897
....................      break;   
043C:  BRA     43E
....................    } 
....................       
....................    data_out = SEGMENT_MAP[data_U2]; 
043E:  MOV.B   896,W0L
0440:  SE      W0,W0
0442:  CALL    200
0446:  MOV.B   W0L,895
....................    if((set_mode)&&(cnt == 0)) 
0448:  BTSS.B  802.2
044A:  BRA     45C
044C:  CP0.B   869
044E:  BRA     NZ,45C
....................    { 
....................      if(flash_dot>20) 
0450:  MOV     806,W4
0452:  LSR     W4,#8,W4
0454:  CP.B    W4L,#14
0456:  BRA     LEU,45C
....................       data_out &=~ 0b10000000; 
0458:  BCLR.B  895.7
....................      else 
045A:  BRA     45C
....................       data_out = data_out; 
....................    }   
....................    if((cnt ==1)&&(mode == nor))//dot for 24 48 V 
045C:  MOV     868,W4
045E:  LSR     W4,#8,W4
0460:  CP.B    W4L,#1
0462:  BRA     NZ,46A
0464:  CP0.B   844
0466:  BRA     NZ,46A
....................    { 
....................      data_out  &=(~0x80); 
0468:  BCLR.B  895.7
....................    }   
....................    for(j=7;j>=0;j--) 
046A:  MOV.B   #7,W0L
046C:  MOV.B   W0L,894
046E:  MOV     894,W4
0470:  CP.B    W4L,#0
0472:  BRA     LT,496
....................    { 
....................       output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
0474:  MOV.B   895,W0L
0476:  MOV     W0,W1
0478:  MOV.B   894,W0L
047A:  BTST.C  W1.W0
047C:  BRA     C,482
047E:  BCLR.B  2CD.4
0480:  BRA     484
0482:  BSET.B  2CD.4
0484:  BCLR.B  2C9.4
....................       output_high(EXP_OUT_CLOCK); 
0486:  BCLR.B  2C9.3
0488:  BSET.B  2CD.3
....................       delay_us(1); 
048A:  REPEAT  #2
048C:  NOP     
....................       output_low(EXP_OUT_CLOCK); 
048E:  BCLR.B  2C9.3
0490:  BCLR.B  2CD.3
....................    }  
0492:  DEC.B   0894
0494:  BRA     46E
....................    /*=========================================*/ 
....................    data_out = SEGMENT_SELECT[data_U1]; 
0496:  MOV.B   897,W0L
0498:  SE      W0,W0
049A:  CALL    21E
049E:  MOV.B   W0L,895
....................     
....................    //$$$$$$$$$$$$$$$jj 
....................    // if VDC < 100 not show lak roi 
....................    if((cnt ==2)&&(roi == 0)) 
04A0:  MOV     868,W4
04A2:  LSR     W4,#8,W4
04A4:  CP.B    W4L,#2
04A6:  BRA     NZ,4B0
04A8:  CP0.B   82F
04AA:  BRA     NZ,4B0
....................      data_out |=0b00000100; 
04AC:  BSET.B  895.2
....................    else if(cnt ==1) 
04AE:  BRA     4C2
04B0:  MOV     868,W4
04B2:  LSR     W4,#8,W4
04B4:  CP.B    W4L,#1
04B6:  BRA     NZ,4C2
....................    { 
....................      if((sib == 0)&&(roi==0)) 
04B8:  CP0.B   842
04BA:  BRA     NZ,4C2
04BC:  CP0.B   82F
04BE:  BRA     NZ,4C2
....................       data_out |=0b00000010;   
04C0:  BSET.B  895.1
....................    } 
....................     
....................    if(mode == nor)   
04C2:  CP0.B   844
04C4:  BRA     NZ,4D2
....................    { 
....................       data_out = data_out |= 0b11110000;  
04C6:  MOV     894,W4
04C8:  LSR     W4,#8,W4
04CA:  IOR.B   #F0,W4L
04CC:  MOV.B   W4L,W0L
04CE:  MOV.B   W0L,895
....................    } 
....................    else if(mode == UnderSet) 
04D0:  BRA     58C
04D2:  MOV     844,W4
04D4:  CP.B    W4L,#1
04D6:  BRA     NZ,4E6
....................    { 
....................      data_out = data_out &= ~0x10;//80 
04D8:  BCLR.B  895.4
....................      data_out = data_out |= 0b11100000;//clear LED Error 
04DA:  MOV     894,W4
04DC:  LSR     W4,#8,W4
04DE:  IOR.B   #E0,W4L
04E0:  MOV.B   W4L,W0L
04E2:  MOV.B   W0L,895
....................    } 
....................    else if(mode == OverSet) 
04E4:  BRA     58C
04E6:  MOV     844,W4
04E8:  CP.B    W4L,#2
04EA:  BRA     NZ,4FA
....................    { 
....................       data_out = data_out &= ~0x20;//40 
04EC:  BCLR.B  895.5
....................       data_out = data_out |= 0b11010000;//clear LED Error 
04EE:  MOV     894,W4
04F0:  LSR     W4,#8,W4
04F2:  IOR.B   #D0,W4L
04F4:  MOV.B   W4L,W0L
04F6:  MOV.B   W0L,895
....................    } 
....................    else if(mode == UnderResSet) 
04F8:  BRA     58C
04FA:  MOV     844,W4
04FC:  CP.B    W4L,#3
04FE:  BRA     NZ,516
....................    { 
....................       data_out = data_out &= ~0b01010000; 
0500:  MOV     894,W4
0502:  LSR     W4,#8,W4
0504:  AND.B   #AF,W4L
0506:  MOV.B   W4L,W0L
0508:  MOV.B   W0L,895
....................       data_out = data_out |=  0b10100000;//clear LED Error 
050A:  MOV     894,W4
050C:  LSR     W4,#8,W4
050E:  IOR.B   #A0,W4L
0510:  MOV.B   W4L,W0L
0512:  MOV.B   W0L,895
....................    } 
....................    else if(mode == OverResSet) 
0514:  BRA     58C
0516:  MOV     844,W4
0518:  CP.B    W4L,#4
051A:  BRA     NZ,532
....................    { 
....................       data_out = data_out &= ~0b01100000; 
051C:  MOV     894,W4
051E:  LSR     W4,#8,W4
0520:  AND.B   #9F,W4L
0522:  MOV.B   W4L,W0L
0524:  MOV.B   W0L,895
....................       data_out = data_out |=  0b10010000;//clear LED Error 
0526:  MOV     894,W4
0528:  LSR     W4,#8,W4
052A:  IOR.B   #90,W4L
052C:  MOV.B   W4L,W0L
052E:  MOV.B   W0L,895
....................    } 
....................    else if(mode == UnderTimSet) 
0530:  BRA     58C
0532:  MOV     844,W4
0534:  CP.B    W4L,#5
0536:  BRA     NZ,54E
....................    { 
....................       data_out = data_out &= ~0b10010000; 
0538:  MOV     894,W4
053A:  LSR     W4,#8,W4
053C:  AND.B   #6F,W4L
053E:  MOV.B   W4L,W0L
0540:  MOV.B   W0L,895
....................       data_out = data_out |=  0b01100000;//clear LED Error 
0542:  MOV     894,W4
0544:  LSR     W4,#8,W4
0546:  IOR.B   #60,W4L
0548:  MOV.B   W4L,W0L
054A:  MOV.B   W0L,895
....................    } 
....................    else if(mode == OverTimSet) 
054C:  BRA     58C
054E:  MOV     844,W4
0550:  CP.B    W4L,#6
0552:  BRA     NZ,56A
....................    { 
....................       data_out = data_out &= ~0b10100000; 
0554:  MOV     894,W4
0556:  LSR     W4,#8,W4
0558:  AND.B   #5F,W4L
055A:  MOV.B   W4L,W0L
055C:  MOV.B   W0L,895
....................       data_out = data_out |=  0b01010000;//clear LED Error 
055E:  MOV     894,W4
0560:  LSR     W4,#8,W4
0562:  IOR.B   #50,W4L
0564:  MOV.B   W4L,W0L
0566:  MOV.B   W0L,895
....................    } 
....................    else if(mode == UnderResTimSet) 
0568:  BRA     58C
056A:  MOV     844,W4
056C:  CP.B    W4L,#7
056E:  BRA     NZ,57E
....................    { 
....................       data_out = data_out &= ~0b11010000;//00000000 
0570:  MOV     894,W4
0572:  LSR     W4,#8,W4
0574:  AND.B   #2F,W4L
0576:  MOV.B   W4L,W0L
0578:  MOV.B   W0L,895
....................       data_out = data_out |=  0b00100000;//clear LED Error 
057A:  BSET.B  895.5
....................    } 
....................    else if(mode == OverResTimSet) 
057C:  BRA     58C
057E:  MOV     844,W4
0580:  CP.B    W4L,#8
0582:  BRA     NZ,58C
....................    { 
....................       data_out = data_out &= ~0b11100000;//00000000 
0584:  MOV.B   895,W0L
0586:  AND.B   W0L,#1F,W0L
0588:  MOV.B   W0L,895
....................       data_out = data_out |=  0b00010000;//clear LED Error 
058A:  BSET.B  895.4
....................    } 
....................    for(j=7;j>=0;j--) 
058C:  MOV.B   #7,W0L
058E:  MOV.B   W0L,894
0590:  MOV     894,W4
0592:  CP.B    W4L,#0
0594:  BRA     LT,5B8
....................    {       
....................       output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
0596:  MOV.B   895,W0L
0598:  MOV     W0,W1
059A:  MOV.B   894,W0L
059C:  BTST.C  W1.W0
059E:  BRA     C,5A4
05A0:  BCLR.B  2CD.4
05A2:  BRA     5A6
05A4:  BSET.B  2CD.4
05A6:  BCLR.B  2C9.4
....................       output_high(EXP_OUT_CLOCK); 
05A8:  BCLR.B  2C9.3
05AA:  BSET.B  2CD.3
....................       delay_us(1); 
05AC:  REPEAT  #2
05AE:  NOP     
....................       output_low(EXP_OUT_CLOCK); 
05B0:  BCLR.B  2C9.3
05B2:  BCLR.B  2CD.3
....................    }   
05B4:  DEC.B   0894
05B6:  BRA     590
....................    output_high(EXP_OUT_ENABLE); 
05B8:  BCLR.B  2C9.2
05BA:  BSET.B  2CD.2
....................    delay_us(1); 
05BC:  REPEAT  #2
05BE:  NOP     
....................    output_low(EXP_OUT_ENABLE); 
05C0:  BCLR.B  2C9.2
05C2:  BCLR.B  2CD.2
.................... } 
05C4:  RETURN  
.................... void StartTimer(void) 
.................... { 
....................    TIMER_Flag = 1; 
*
15E8:  MOV.B   #1,W0L
15EA:  MOV.B   W0L,868
.................... } 
15EC:  RETURN  
.................... void StopTimer(void) 
.................... { 
....................    TIMER_Flag = 0; 
15EE:  CLR.B   868
.................... } 
15F0:  RETURN  
....................  
.................... void Read_VDC(void) 
.................... { 
15F2:  MOV     W5,[W15++]
15F4:  MOV     W6,[W15++]
15F6:  MOV     W7,[W15++]
15F8:  MOV     W8,[W15++]
....................   real_data = Soft_read_adc_mcp(); 
15FA:  CALL    B42
15FE:  MOV     W0,830
....................   
....................   vout = (real_data * 2.048) / 32767.0; // see text 
1600:  MOV     830,W5
1602:  MOV     W5,W0
1604:  CLR     W3
1606:  BTSC    W0.F
1608:  SETM    W3
160A:  MOV     W3,W1
160C:  MOV     W3,W2
160E:  CALL    B80
1612:  MOV     W5,[W15++]
1614:  MOV     #A9FC,W4
1616:  MOV     #D2F1,W5
1618:  MOV     #624D,W6
161A:  MOV     #4000,W7
161C:  CALL    BE4
1620:  MOV     [--W15],W5
1622:  MOV     W0,W5
1624:  MOV     W1,W6
1626:  MOV     W2,W7
1628:  MOV     W3,W8
162A:  MOV     W5,[W15++]
162C:  MOV     W6,[W15++]
162E:  MOV     W7,[W15++]
1630:  MOV     W5,W0
1632:  MOV     W6,W1
1634:  MOV     W7,W2
1636:  MOV     W8,W3
1638:  MOV     #0,W4
163A:  MOV     #0,W5
163C:  MOV     #FFC0,W6
163E:  MOV     #40DF,W7
1640:  CALL    CF2
1644:  MOV     [--W15],W7
1646:  MOV     [--W15],W6
1648:  MOV     [--W15],W5
164A:  CALL    DFA
164E:  MOV     W1,832
1650:  MOV     W2,834
....................   vin = vout / (R2/(R1+R2)); 
1652:  BCLR.B  43.0
1654:  MOV     83A,W0
1656:  MOV     83C,W1
1658:  MOV     83E,W2
165A:  MOV     840,W3
165C:  CALL    91C
1660:  MOV     W0,W2
1662:  MOV     W1,W3
1664:  MOV     83E,W0
1666:  MOV     840,W1
1668:  CALL    E3E
166C:  MOV     W0,W2
166E:  MOV     W1,W3
1670:  MOV     832,W0
1672:  MOV     834,W1
1674:  CALL    E3E
1678:  MOV     W0,836
167A:  MOV     W1,838
....................    
....................   DC_V =(int16)vin; 
167C:  PUSH    42
167E:  SETM.B  42
1680:  MOV     836,W0
1682:  MOV     838,W1
1684:  CALL    31A
1688:  POP     42
168A:  MOV     W0,808
....................  
....................   vin = vin*10.0;  // for 24 48 V  
168C:  MOV     836,W0
168E:  MOV     838,W1
1690:  MOV     #0,W2
1692:  MOV     #4120,W3
1694:  CALL    152A
1698:  MOV     W0,836
169A:  MOV     W1,838
....................   DC_V7seg = (int16)vin; 
169C:  PUSH    42
169E:  SETM.B  42
16A0:  MOV     836,W0
16A2:  MOV     838,W1
16A4:  CALL    31A
16A8:  POP     42
16AA:  MOV     W0,80A
....................    
....................   if((DC_V<0)||(DC_V>300)) 
16AC:  MOV     808,W4
16AE:  MOV     #12C,W3
16B0:  CP      W3,W4
16B2:  BRA     C,16B8
....................   { 
....................     DC_V =0; 
16B4:  CLR     808
....................     DC_V7seg=0; 
16B6:  CLR     80A
....................   } 
....................    
....................   int8 i; 
....................   for(i=0;i<10;i++) 
16B8:  CLR.B   876
16BA:  MOV     876,W4
16BC:  CP.B    W4L,#A
16BE:  BRA     GE,16E4
....................   { 
....................     DC_Average[i] = DC_Average[i+1]; 
16C0:  MOV.B   876,W0L
16C2:  SE      W0,W0
16C4:  MOV     W0,W4
16C6:  MUL.UU  W4,#2,W0
16C8:  MOV     #80C,W4
16CA:  ADD     W0,W4,W5
16CC:  MOV     876,W4
16CE:  ADD.B   W4L,#1,W4L
16D0:  MOV.B   W4L,W0L
16D2:  MOV.B   W0L,0
16D4:  MOV.B   W0L,W4L
16D6:  CLR.B   9
16D8:  MUL.UU  W4,#2,W0
16DA:  MOV     #80C,W4
16DC:  ADD     W0,W4,W0
16DE:  MOV     [W0],[W5]
....................   } 
16E0:  INC.B   0876
16E2:  BRA     16BA
....................   DC_Average[10] = DC_V7seg; 
16E4:  PUSH    80A
16E6:  POP     820
....................    
....................   DC_V7seg =0; 
16E8:  CLR     80A
....................    
....................   DC_V7seg = DC_Average[0]; 
16EA:  PUSH    80C
16EC:  POP     80A
....................   DC_V7seg = DC_V7seg + DC_Average[1]; 
16EE:  MOV     80A,W0
16F0:  ADD     80E,W0
16F2:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[2]; 
16F4:  MOV     80A,W0
16F6:  ADD     810,W0
16F8:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[3]; 
16FA:  MOV     80A,W0
16FC:  ADD     812,W0
16FE:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[4]; 
1700:  MOV     80A,W0
1702:  ADD     814,W0
1704:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[5]; 
1706:  MOV     80A,W0
1708:  ADD     816,W0
170A:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[6]; 
170C:  MOV     80A,W0
170E:  ADD     818,W0
1710:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[7]; 
1712:  MOV     80A,W0
1714:  ADD     81A,W0
1716:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[8]; 
1718:  MOV     80A,W0
171A:  ADD     81C,W0
171C:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg + DC_Average[9]; 
171E:  MOV     80A,W0
1720:  ADD     81E,W0
1722:  MOV     W0,80A
....................   DC_V7seg = DC_V7seg/10; 
1724:  MOV     80A,W4
1726:  MOV     #A,W3
1728:  REPEAT  #11
172A:  DIV.S   W4,W3
172C:  MOV     W0,80A
....................    
....................    
.................... //enum{State_nor,State_PreUnder,State_Under,State_PreUnderRes,State_UnderRes,State_PreOver,State_Over,State_PreOverRes,State_OverRes};  
.................... // ************************UNDER********************* 
....................    if(StartMeasureCount <=0) 
172E:  MOV     866,W4
1730:  CP      W4,#0
1732:  BRA     GT,18CC
....................    { 
....................      if((DC_V <= UnderValue)&&(State == State_nor)) 
1734:  MOV     808,W0
1736:  CALL    87A
173A:  MOV     856,W2
173C:  MOV     858,W3
173E:  CALL    8B4
1742:  BRA     C,1746
1744:  BRA     NZ,17CC
1746:  CP0.B   845
1748:  BRA     NZ,17CC
....................      { 
....................        UnderTimeCount = UnderTimSetValue*1000; 
174A:  MOV     852,W4
174C:  MOV     #3E8,W3
174E:  MUL.SS  W4,W3,W0
1750:  MOV     W0,84A
....................        switch(UnderTimeCount) 
....................        { 
1752:  MOV     84A,W0
1754:  MOV     #3E8,W4
1756:  CP      W0,W4
1758:  BRA     Z,1774
175A:  MOV     #7D0,W4
175C:  CP      W0,W4
175E:  BRA     Z,177C
1760:  MOV     #BB8,W4
1762:  CP      W0,W4
1764:  BRA     Z,1784
1766:  MOV     #FA0,W4
1768:  CP      W0,W4
176A:  BRA     Z,178C
176C:  MOV     #1388,W4
176E:  CP      W0,W4
1770:  BRA     Z,1794
1772:  BRA     179C
....................          case 1000: 
....................             UnderTimeCount =UnderTimeCount-80; 
1774:  MOV     84A,W4
1776:  SUB     #50,W4
1778:  MOV     W4,84A
....................          break; 
177A:  BRA     179E
....................          case 2000: 
....................             UnderTimeCount =UnderTimeCount-100; 
177C:  MOV     84A,W4
177E:  SUB     #64,W4
1780:  MOV     W4,84A
....................          break; 
1782:  BRA     179E
....................          case 3000: 
....................             UnderTimeCount =UnderTimeCount-100; 
1784:  MOV     84A,W4
1786:  SUB     #64,W4
1788:  MOV     W4,84A
....................          break; 
178A:  BRA     179E
....................          case 4000: 
....................             UnderTimeCount =UnderTimeCount-70; 
178C:  MOV     84A,W4
178E:  SUB     #46,W4
1790:  MOV     W4,84A
....................          break; 
1792:  BRA     179E
....................          case 5000: 
....................             UnderTimeCount =UnderTimeCount-100; 
1794:  MOV     84A,W4
1796:  SUB     #64,W4
1798:  MOV     W4,84A
....................          break; 
179A:  BRA     179E
....................          default: 
....................             UnderTimeCount =UnderTimeCount-0; 
....................          break; 
179C:  BRA     179E
....................        } 
....................        FlashLEDUnder = true;      
179E:  BSET.B  802.0
....................        State = State_PreUnder; 
17A0:  MOV.B   #1,W0L
17A2:  MOV.B   W0L,845
....................        if(UnderTimeCount ==0) 
17A4:  CP0     84A
17A6:  BRA     NZ,17C0
....................        { 
....................          output_low(Under_Rly);//on rly 
17A8:  BCLR.B  2C8.6
17AA:  BCLR.B  2CC.6
....................          output_low(Over_Rly);//on rly 
17AC:  BCLR.B  2C8.7
17AE:  BCLR.B  2CC.7
....................          State = State_Under; 
17B0:  MOV.B   #2,W0L
17B2:  MOV.B   W0L,845
....................          FlashLEDUnder = false;   
17B4:  BCLR.B  802.0
....................          output_high(LED_Under);//on led 
17B6:  BCLR.B  2C8.4
17B8:  BSET.B  2CC.4
....................          output_low(LED_Over); 
17BA:  BCLR.B  2C8.0
17BC:  BCLR.B  2CC.0
....................        } 
....................        else 
17BE:  BRA     17CC
....................        { 
....................          if(Timer_flag ==0) 
17C0:  CP0.B   868
17C2:  BRA     NZ,17C8
....................          { 
....................             StartTimer(); 
17C4:  CALL    15E8
....................          } 
....................          output_high(PIN_B3); 
17C8:  BCLR.B  2C8.3
17CA:  BSET.B  2CC.3
....................        }    
....................      } 
....................      if((DC_V >= UnderValue) && (State == State_PreUnder))  
17CC:  MOV     808,W0
17CE:  CALL    87A
17D2:  MOV     W0,W2
17D4:  MOV     W1,W3
17D6:  MOV     856,W0
17D8:  MOV     858,W1
17DA:  CALL    8B4
17DE:  BRA     C,17E2
17E0:  BRA     NZ,17FC
17E2:  MOV     844,W4
17E4:  LSR     W4,#8,W4
17E6:  CP.B    W4L,#1
17E8:  BRA     NZ,17FC
....................      { 
....................        output_low(LED_Under); 
17EA:  BCLR.B  2C8.4
17EC:  BCLR.B  2CC.4
....................        output_high(LED_Over);  
17EE:  BCLR.B  2C8.0
17F0:  BSET.B  2CC.0
....................        UnderTimeCount = 0; 
17F2:  CLR     84A
....................        State = State_nor; 
17F4:  CLR.B   845
....................        FlashLEDUnder = false; //on led  
17F6:  BCLR.B  802.0
....................        StopTimer(); 
17F8:  CALL    15EE
....................      } 
....................       
....................      if((DC_V >= UnderResValue) && (State == State_Under)) 
17FC:  MOV     808,W0
17FE:  CALL    87A
1802:  MOV     W0,W2
1804:  MOV     W1,W3
1806:  MOV     85E,W0
1808:  MOV     860,W1
180A:  CALL    8B4
180E:  BRA     C,1812
1810:  BRA     NZ,189E
1812:  MOV     844,W4
1814:  LSR     W4,#8,W4
1816:  CP.B    W4L,#2
1818:  BRA     NZ,189E
....................      { 
....................        UnderResTimeCount = UnderResTimSetValue*1000; //40*25ms = 1 Sec 
181A:  MOV     850,W4
181C:  MOV     #3E8,W3
181E:  MUL.SS  W4,W3,W0
1820:  MOV     W0,846
....................        switch(UnderResTimeCount) 
....................        { 
1822:  MOV     846,W0
1824:  MOV     #3E8,W4
1826:  CP      W0,W4
1828:  BRA     Z,1844
182A:  MOV     #7D0,W4
182C:  CP      W0,W4
182E:  BRA     Z,184C
1830:  MOV     #BB8,W4
1832:  CP      W0,W4
1834:  BRA     Z,1854
1836:  MOV     #FA0,W4
1838:  CP      W0,W4
183A:  BRA     Z,185C
183C:  MOV     #1388,W4
183E:  CP      W0,W4
1840:  BRA     Z,1864
1842:  BRA     186C
....................          case 1000: 
....................             UnderResTimeCount =UnderResTimeCount-80; 
1844:  MOV     846,W4
1846:  SUB     #50,W4
1848:  MOV     W4,846
....................          break; 
184A:  BRA     186E
....................          case 2000: 
....................             UnderResTimeCount =UnderResTimeCount-50; 
184C:  MOV     846,W4
184E:  SUB     #32,W4
1850:  MOV     W4,846
....................          break; 
1852:  BRA     186E
....................          case 3000: 
....................             UnderResTimeCount =UnderResTimeCount-70; 
1854:  MOV     846,W4
1856:  SUB     #46,W4
1858:  MOV     W4,846
....................          break; 
185A:  BRA     186E
....................          case 4000: 
....................             UnderResTimeCount =UnderResTimeCount-70; 
185C:  MOV     846,W4
185E:  SUB     #46,W4
1860:  MOV     W4,846
....................          break; 
1862:  BRA     186E
....................          case 5000: 
....................             UnderResTimeCount =UnderResTimeCount-70; 
1864:  MOV     846,W4
1866:  SUB     #46,W4
1868:  MOV     W4,846
....................          break; 
186A:  BRA     186E
....................          default: 
....................             UnderResTimeCount =UnderResTimeCount-0; 
....................          break; 
186C:  BRA     186E
....................        } 
....................        FlashLEDOver = true; 
186E:  BSET.B  802.1
....................        State = State_PreUnderRes; 
1870:  MOV.B   #3,W0L
1872:  MOV.B   W0L,845
....................        if(UnderResTimeCount == 0) 
1874:  CP0     846
1876:  BRA     NZ,1896
....................        { 
....................           output_high(Under_Rly);  
1878:  BCLR.B  2C8.6
187A:  BSET.B  2CC.6
....................           output_high(Over_Rly);  
187C:  BCLR.B  2C8.7
187E:  BSET.B  2CC.7
....................           if(State == State_PreUnderRes) 
1880:  MOV     844,W4
1882:  LSR     W4,#8,W4
1884:  CP.B    W4L,#3
1886:  BRA     NZ,188A
....................           { 
....................              State = State_nor; 
1888:  CLR.B   845
....................           } 
....................           FlashLEDOver = false; 
188A:  BCLR.B  802.1
....................           output_low(LED_Under);  
188C:  BCLR.B  2C8.4
188E:  BCLR.B  2CC.4
....................           output_high(LED_Over);  
1890:  BCLR.B  2C8.0
1892:  BSET.B  2CC.0
....................        } 
....................        else 
1894:  BRA     189E
....................        { 
....................          if(Timer_flag ==0) 
1896:  CP0.B   868
1898:  BRA     NZ,189E
....................          { 
....................             StartTimer(); 
189A:  CALL    15E8
....................          } 
....................        }      
....................      } 
....................      if((DC_V <= UnderResValue)&&(State == State_PreUnderRes)) 
189E:  MOV     808,W0
18A0:  CALL    87A
18A4:  MOV     85E,W2
18A6:  MOV     860,W3
18A8:  CALL    8B4
18AC:  BRA     C,18B0
18AE:  BRA     NZ,18CC
18B0:  MOV     844,W4
18B2:  LSR     W4,#8,W4
18B4:  CP.B    W4L,#3
18B6:  BRA     NZ,18CC
....................      { 
....................         output_high(LED_Under); 
18B8:  BCLR.B  2C8.4
18BA:  BSET.B  2CC.4
....................         output_low(LED_Over);  
18BC:  BCLR.B  2C8.0
18BE:  BCLR.B  2CC.0
....................         State = State_Under; 
18C0:  MOV.B   #2,W0L
18C2:  MOV.B   W0L,845
....................         UnderResTimeCount = 0; 
18C4:  CLR     846
....................         FlashLEDUnder = false; 
18C6:  BCLR.B  802.0
....................         StopTimer(); 
18C8:  CALL    15EE
....................      }   
....................    }  
.................... } 
18CC:  MOV     [--W15],W8
18CE:  MOV     [--W15],W7
18D0:  MOV     [--W15],W6
18D2:  MOV     [--W15],W5
18D4:  RETURN  
....................  
.................... void buttonRead() 
.................... { 
*
11DC:  MOV     W5,[W15++]
11DE:  MOV     W6,[W15++]
11E0:  MOV     W7,[W15++]
....................   enum{st1,st2,st3,st4,st5}; 
....................   static unsigned int state,deb; //deb==Debount 
*
193C:  CLR     86E
193E:  CLR     870
....................   int tempValue;   
....................   if((input(BT_SET) == 1)&&(input(BT_UP) == 1)&&(input(BT_DW) == 1)) 
*
11E2:  BSET.B  2C9.7
11E4:  BTSS.B  2CB.7
11E6:  BRA     11F8
11E8:  BSET.B  2C9.6
11EA:  BTSS.B  2CB.6
11EC:  BRA     11F8
11EE:  BSET.B  2C9.5
11F0:  BTSS.B  2CB.5
11F2:  BRA     11F8
....................   {         
....................      state = st1;      
11F4:  CLR     86E
....................      return;  
11F6:  BRA     1522
....................   }   
....................   if(((input(BT_SET) == 0)||(input(BT_UP) == 0)||(input(BT_DW) == 0))&&state == st1) 
11F8:  BSET.B  2C9.7
11FA:  BTSS.B  2CB.7
11FC:  BRA     120A
11FE:  BSET.B  2C9.6
1200:  BTSS.B  2CB.6
1202:  BRA     120A
1204:  BSET.B  2C9.5
1206:  BTSC.B  2CB.5
1208:  BRA     1218
120A:  CP0     86E
120C:  BRA     NZ,1218
....................   {      
....................      state = st2; 
120E:  MOV     #1,W4
1210:  MOV     W4,86E
....................      deb = 1; //debound     
1212:  MOV     #1,W4
1214:  MOV     W4,870
....................      return; 
1216:  BRA     1522
....................   } 
....................   if(((input(BT_SET) == 0)||(input(BT_UP) == 0)||(input(BT_DW) == 0))&&state == st2) 
1218:  BSET.B  2C9.7
121A:  BTSS.B  2CB.7
121C:  BRA     122A
121E:  BSET.B  2C9.6
1220:  BTSS.B  2CB.6
1222:  BRA     122A
1224:  BSET.B  2C9.5
1226:  BTSC.B  2CB.5
1228:  BRA     14FE
122A:  MOV     86E,W4
122C:  CP      W4,#1
122E:  BRA     NZ,14FE
....................   { 
....................     if(deb) 
1230:  CP0     870
1232:  BRA     Z,123A
....................     {      
....................       deb--; 
1234:  DEC     0870
....................       return; 
1236:  BRA     1522
....................     }     
....................     else    
1238:  BRA     14FE
....................     {  
....................       if(input(BT_SET) == 0) 
123A:  BSET.B  2C9.7
123C:  BTSC.B  2CB.7
123E:  BRA     1302
....................       { 
....................         if(++mode > UnderResTimSet_UnOly)mode = Nor_UnOly; 
1240:  INC.B   0844
1242:  MOV     844,W4
1244:  CP.B    W4L,#4
1246:  BRA     LEU,124A
1248:  CLR.B   844
....................         ///////////////////////// 
....................   
....................         ///////////////////////// 
....................         if(mode == Nor_UnOly)         
124A:  CP0.B   844
124C:  BRA     NZ,1262
....................         { 
....................            if(set_mode) 
124E:  BTSS.B  802.2
1250:  BRA     1260
....................            { 
....................              set_mode = false; 
1252:  BCLR.B  802.2
....................              write_ext_eeprom(UnderResTimSet_addr,UnderResTimSetValue); 
1254:  MOV.B   #6,W0L
1256:  MOV.B   W0L,87A
1258:  MOV.B   850,W0L
125A:  MOV.B   W0L,87B
125C:  CALL    F08
....................            } 
....................          }         
....................          else if((mode == UnderSet_UnOly)) 
1260:  BRA     12F2
1262:  MOV     844,W4
1264:  CP.B    W4L,#1
1266:  BRA     NZ,1276
....................          {   
....................            menuCount =1500*3000; 
1268:  MOV     #AA20,W4
126A:  MOV     W4,824
126C:  MOV     #44,W4
126E:  MOV     W4,826
....................            if(set_mode)    
1270:  BTSS.B  802.2
1272:  BRA     1274
....................            { 
....................              ; 
....................            } 
....................          } 
....................          else if((mode == UnderResSet_UnOly)) 
1274:  BRA     12F2
1276:  MOV     844,W4
1278:  CP.B    W4L,#2
127A:  BRA     NZ,12A4
....................          { 
....................            menuCount =1500*3000; 
127C:  MOV     #AA20,W4
127E:  MOV     W4,824
1280:  MOV     #44,W4
1282:  MOV     W4,826
....................            if(set_mode) 
1284:  BTSS.B  802.2
1286:  BRA     12A2
....................            {  
....................              write_ext_eeprom(UnderSet_addr,UnderValue); 
1288:  PUSH    42
128A:  SETM.B  42
128C:  MOV     856,W0
128E:  MOV     858,W1
1290:  CALL    31A
1294:  POP     42
1296:  MOV.B   W0L,W5L
1298:  CLR.B   87A
129A:  MOV.B   W5L,W0L
129C:  MOV.B   W0L,87B
129E:  CALL    F08
....................            } 
....................          }  
....................          else if((mode == UnderTimSet_UnOly)) 
12A2:  BRA     12F2
12A4:  MOV     844,W4
12A6:  CP.B    W4L,#3
12A8:  BRA     NZ,12D4
....................          { 
....................            menuCount =1500*3000; 
12AA:  MOV     #AA20,W4
12AC:  MOV     W4,824
12AE:  MOV     #44,W4
12B0:  MOV     W4,826
....................            if(set_mode) 
12B2:  BTSS.B  802.2
12B4:  BRA     12D2
....................            {  
....................              write_ext_eeprom(UnderResSet_addr,UnderResValue);  
12B6:  PUSH    42
12B8:  SETM.B  42
12BA:  MOV     85E,W0
12BC:  MOV     860,W1
12BE:  CALL    31A
12C2:  POP     42
12C4:  MOV.B   W0L,W5L
12C6:  MOV.B   #2,W0L
12C8:  MOV.B   W0L,87A
12CA:  MOV.B   W5L,W0L
12CC:  MOV.B   W0L,87B
12CE:  CALL    F08
....................            } 
....................          } 
....................          else if((mode == UnderResTimSet_UnOly)) 
12D2:  BRA     12F2
12D4:  MOV     844,W4
12D6:  CP.B    W4L,#4
12D8:  BRA     NZ,12F2
....................          { 
....................            menuCount =1500*3000; 
12DA:  MOV     #AA20,W4
12DC:  MOV     W4,824
12DE:  MOV     #44,W4
12E0:  MOV     W4,826
....................            if(set_mode) 
12E2:  BTSS.B  802.2
12E4:  BRA     12F2
....................            {   
....................              write_ext_eeprom(UnderTimSet_addr,UnderTimSetValue);   
12E6:  MOV.B   #4,W0L
12E8:  MOV.B   W0L,87A
12EA:  MOV.B   852,W0L
12EC:  MOV.B   W0L,87B
12EE:  CALL    F08
....................            }  
....................          } 
....................  
....................          menuCount =1500*3000; 
12F2:  MOV     #AA20,W4
12F4:  MOV     W4,824
12F6:  MOV     #44,W4
12F8:  MOV     W4,826
....................          deb = 20; //Press hold 3sec for Enter Set mode.(60*50 =3000) 
12FA:  MOV     #14,W4
12FC:  MOV     W4,870
....................          state = st3; 
12FE:  MOV     #2,W4
1300:  MOV     W4,86E
....................          ////////////////////////////////// 
....................       } 
....................       if((input(BT_UP) == 0)&&set_mode == true)      
1302:  BSET.B  2C9.6
1304:  BTSC.B  2CB.6
1306:  BRA     1428
1308:  BTSS.B  802.2
130A:  BRA     1428
....................       { 
....................         switch(mode) 
....................         { 
130C:  MOV.B   844,W0L
130E:  CLR.B   1
1310:  XOR     #1,W0
1312:  BRA     Z,1322
1314:  XOR     #3,W0
1316:  BRA     Z,1368
1318:  XOR     #1,W0
131A:  BRA     Z,13A4
131C:  XOR     #7,W0
131E:  BRA     Z,13E0
1320:  BRA     141C
....................           case UnderSet_UnOly: 
....................             tempValue = UnderValue; 
1322:  PUSH    42
1324:  SETM.B  42
1326:  MOV     856,W0
1328:  MOV     858,W1
132A:  CALL    31A
132E:  POP     42
1330:  MOV     W0,876
....................             //UnderValue++; 
....................             UnderValue += 0.1; 
1332:  BCLR.B  43.0
1334:  MOV     856,W0
1336:  MOV     858,W1
1338:  MOV     #CCCD,W2
133A:  MOV     #3DCC,W3
133C:  CALL    91C
1340:  MOV     W0,856
1342:  MOV     W1,858
....................             if(UnderValue > UnderResValue-1) 
1344:  BSET.B  43.0
1346:  MOV     85E,W0
1348:  MOV     860,W1
134A:  MOV     #0,W2
134C:  MOV     #3F80,W3
134E:  CALL    91C
1352:  MOV     856,W2
1354:  MOV     858,W3
1356:  CALL    8B4
135A:  BRA     NC,1366
....................             { 
....................                UnderValue = tempValue; 
135C:  MOV     876,W0
135E:  CALL    F60
1362:  MOV     W0,856
1364:  MOV     W1,858
....................             } 
....................           break; 
1366:  BRA     141C
....................            
....................           case UnderResSet_UnOly: 
....................             tempValue = UnderResValue; 
1368:  PUSH    42
136A:  SETM.B  42
136C:  MOV     85E,W0
136E:  MOV     860,W1
1370:  CALL    31A
1374:  POP     42
1376:  MOV     W0,876
....................             UnderResValue += 0.1; 
1378:  BCLR.B  43.0
137A:  MOV     85E,W0
137C:  MOV     860,W1
137E:  MOV     #CCCD,W2
1380:  MOV     #3DCC,W3
1382:  CALL    91C
1386:  MOV     W0,85E
1388:  MOV     W1,860
....................             if(UnderResValue > NORMAL_VOLT)UnderResValue = tempValue; 
138A:  MOV     #0,W0
138C:  MOV     #41C0,W1
138E:  MOV     85E,W2
1390:  MOV     860,W3
1392:  CALL    8B4
1396:  BRA     NC,13A2
1398:  MOV     876,W0
139A:  CALL    F60
139E:  MOV     W0,85E
13A0:  MOV     W1,860
....................           break; 
13A2:  BRA     141C
....................            
....................           case UnderTimSet_UnOly: 
....................             tempValue = UnderTimSetValue; 
13A4:  PUSH    852
13A6:  POP     876
....................             UnderTimSetValue += 0.1; 
13A8:  MOV     852,W5
13AA:  MOV     W5,W0
13AC:  CLR     W3
13AE:  BTSC    W0.F
13B0:  SETM    W3
13B2:  MOV     W3,W1
13B4:  MOV     W3,W2
13B6:  CALL    B80
13BA:  BCLR.B  43.0
13BC:  MOV     W5,[W15++]
13BE:  MOV     #999A,W4
13C0:  MOV     #9999,W5
13C2:  MOV     #9999,W6
13C4:  MOV     #3FB9,W7
13C6:  CALL    FAA
13CA:  MOV     [--W15],W5
13CC:  CALL    1186
13D0:  MOV     W0,852
....................             if(UnderTimSetValue > MAX_TIME)UnderTimSetValue = tempValue; 
13D2:  MOV     852,W4
13D4:  MOV     #3C,W3
13D6:  CP      W3,W4
13D8:  BRA     GE,13DE
13DA:  PUSH    876
13DC:  POP     852
....................           break; 
13DE:  BRA     141C
....................  
....................           case UnderResTimSet_UnOly: 
....................             tempValue = UnderResTimSetValue; 
13E0:  PUSH    850
13E2:  POP     876
....................             UnderResTimSetValue += 0.1; 
13E4:  MOV     850,W5
13E6:  MOV     W5,W0
13E8:  CLR     W3
13EA:  BTSC    W0.F
13EC:  SETM    W3
13EE:  MOV     W3,W1
13F0:  MOV     W3,W2
13F2:  CALL    B80
13F6:  BCLR.B  43.0
13F8:  MOV     W5,[W15++]
13FA:  MOV     #999A,W4
13FC:  MOV     #9999,W5
13FE:  MOV     #9999,W6
1400:  MOV     #3FB9,W7
1402:  CALL    FAA
1406:  MOV     [--W15],W5
1408:  CALL    1186
140C:  MOV     W0,850
....................             if(UnderResTimSetValue > MAX_TIME) UnderResTimSetValue = tempValue; 
140E:  MOV     850,W4
1410:  MOV     #3C,W3
1412:  CP      W3,W4
1414:  BRA     GE,141A
1416:  PUSH    876
1418:  POP     850
....................           break; 
141A:  BRA     141C
....................             
....................         } 
....................         /////////////////////////////////// 
....................         state = st4; 
141C:  MOV     #3,W4
141E:  MOV     W4,86E
....................         menuCount =1500*3000; 
1420:  MOV     #AA20,W4
1422:  MOV     W4,824
1424:  MOV     #44,W4
1426:  MOV     W4,826
....................       } 
....................       if((input(BT_DW) == 0)&&set_mode == true)      
1428:  BSET.B  2C9.5
142A:  BTSC.B  2CB.5
142C:  BRA     14FE
142E:  BTSS.B  802.2
1430:  BRA     14FE
....................       { 
....................         switch(mode) 
....................         { 
1432:  MOV.B   844,W0L
1434:  CLR.B   1
1436:  XOR     #1,W0
1438:  BRA     Z,1448
143A:  XOR     #3,W0
143C:  BRA     Z,1484
143E:  XOR     #1,W0
1440:  BRA     Z,14CE
1442:  XOR     #7,W0
1444:  BRA     Z,14E0
1446:  BRA     14F2
....................           case UnderSet_UnOly: 
....................           tempValue = UnderValue; 
1448:  PUSH    42
144A:  SETM.B  42
144C:  MOV     856,W0
144E:  MOV     858,W1
1450:  CALL    31A
1454:  POP     42
1456:  MOV     W0,876
....................           UnderValue -= 0.1; 
1458:  BSET.B  43.0
145A:  MOV     856,W0
145C:  MOV     858,W1
145E:  MOV     #CCCD,W2
1460:  MOV     #3DCC,W3
1462:  CALL    91C
1466:  MOV     W0,856
1468:  MOV     W1,858
....................           if(UnderValue < MIN_VOLT)UnderValue = tempValue; 
146A:  MOV     856,W0
146C:  MOV     858,W1
146E:  MOV     #0,W2
1470:  MOV     #4170,W3
1472:  CALL    8B4
1476:  BRA     NC,1482
1478:  MOV     876,W0
147A:  CALL    F60
147E:  MOV     W0,856
1480:  MOV     W1,858
....................           break; 
1482:  BRA     14F2
....................  
....................           case UnderResSet_UnOly: 
....................           tempValue = UnderResValue; 
1484:  PUSH    42
1486:  SETM.B  42
1488:  MOV     85E,W0
148A:  MOV     860,W1
148C:  CALL    31A
1490:  POP     42
1492:  MOV     W0,876
....................           UnderResValue -= 0.1; 
1494:  BSET.B  43.0
1496:  MOV     85E,W0
1498:  MOV     860,W1
149A:  MOV     #CCCD,W2
149C:  MOV     #3DCC,W3
149E:  CALL    91C
14A2:  MOV     W0,85E
14A4:  MOV     W1,860
....................           if(UnderResValue < UnderValue +1)UnderResValue = tempValue; 
14A6:  BCLR.B  43.0
14A8:  MOV     856,W0
14AA:  MOV     858,W1
14AC:  MOV     #0,W2
14AE:  MOV     #3F80,W3
14B0:  CALL    91C
14B4:  MOV     W0,W2
14B6:  MOV     W1,W3
14B8:  MOV     85E,W0
14BA:  MOV     860,W1
14BC:  CALL    8B4
14C0:  BRA     NC,14CC
14C2:  MOV     876,W0
14C4:  CALL    F60
14C8:  MOV     W0,85E
14CA:  MOV     W1,860
....................           break; 
14CC:  BRA     14F2
....................  
....................           case UnderTimSet_UnOly: 
....................           tempValue = UnderTimSetValue; 
14CE:  PUSH    852
14D0:  POP     876
....................           UnderTimSetValue--; 
14D2:  DEC     0852
....................           if(UnderTimSetValue < MIN_TIME) UnderTimSetValue = tempValue; 
14D4:  MOV     852,W4
14D6:  CP      W4,#0
14D8:  BRA     GE,14DE
14DA:  PUSH    876
14DC:  POP     852
....................           break; 
14DE:  BRA     14F2
....................  
....................           case UnderResTimSet_UnOly: 
....................           tempValue = UnderResTimSetValue; 
14E0:  PUSH    850
14E2:  POP     876
....................           UnderResTimSetValue--; 
14E4:  DEC     0850
....................           if(UnderResTimSetValue < MIN_TIME)UnderResTimSetValue = tempValue; 
14E6:  MOV     850,W4
14E8:  CP      W4,#0
14EA:  BRA     GE,14F0
14EC:  PUSH    876
14EE:  POP     850
....................           break; 
14F0:  BRA     14F2
....................  
....................         } 
....................          
....................         state = st4; 
14F2:  MOV     #3,W4
14F4:  MOV     W4,86E
....................         menuCount =1500*3000; 
14F6:  MOV     #AA20,W4
14F8:  MOV     W4,824
14FA:  MOV     #44,W4
14FC:  MOV     W4,826
....................       } 
....................     } 
....................   } 
....................   if((input(BT_SET) == 0)&&state == st3) 
14FE:  BSET.B  2C9.7
1500:  BTSC.B  2CB.7
1502:  BRA     1522
1504:  MOV     86E,W4
1506:  CP      W4,#2
1508:  BRA     NZ,1522
....................   { 
....................     if(deb) 
150A:  CP0     870
150C:  BRA     Z,1514
....................     { 
....................       deb--; 
150E:  DEC     0870
....................       return; 
1510:  BRA     1522
....................     } 
....................     else 
1512:  BRA     151A
....................     { 
....................       //if(set_mode==false)flash_dot =40; 
....................       set_mode = true; 
1514:  BSET.B  802.2
....................       mode = UnderSet; 
1516:  MOV.B   #1,W0L
1518:  MOV.B   W0L,844
....................     } 
....................     menuCount =1500*3000;   
151A:  MOV     #AA20,W4
151C:  MOV     W4,824
151E:  MOV     #44,W4
1520:  MOV     W4,826
....................   } 
.................... } 
1522:  MOV     [--W15],W7
1524:  MOV     [--W15],W6
1526:  MOV     [--W15],W5
1528:  RETURN  
.................... void adjusttime(v0id) 
.................... { 
....................     
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////// 
.................... #int_TIMER3 
.................... void TIMER3_isr(void)//1ms interrupt     
.................... { 
*
0236:  PUSH    42
0238:  PUSH    36
023A:  MOV     W0,[W15++]
023C:  MOV     #2,W0
023E:  REPEAT  #C
0240:  MOV     [W0++],[W15++]
....................    if(TIMER_Flag) 
0242:  CP0.B   868
0244:  BRA     Z,30A
....................    { 
....................      //flash_LED++;  
....................      flash_LED_Under++;  
0246:  INC.B   0803
....................      flash_LED_Over++; 
0248:  INC.B   0804
....................       
....................  
....................       
....................      /////////////// Under ////////////////////// 
....................      if(UnderTimeCount) 
024A:  CP0     84A
024C:  BRA     Z,29A
....................      { 
....................        if(flash_LED_Under >=200) 
024E:  MOV     802,W4
0250:  LSR     W4,#8,W4
0252:  MOV     #C8,W3
0254:  CP.B    W3L,W4L
0256:  BRA     GTU,270
....................        {         
....................          if(toggle_pin_under ==1) 
0258:  MOV     804,W4
025A:  LSR     W4,#8,W4
025C:  CP.B    W4L,#1
025E:  BRA     NZ,268
....................          { 
....................             toggle_pin_under =0; 
0260:  CLR.B   805
....................             output_high(LED_Under);  
0262:  BCLR.B  2C8.4
0264:  BSET.B  2CC.4
....................          } 
....................          else 
0266:  BRA     270
....................          { 
....................             toggle_pin_under =1; 
0268:  MOV.B   #1,W0L
026A:  MOV.B   W0L,805
....................             output_low(LED_Under); 
026C:  BCLR.B  2C8.4
026E:  BCLR.B  2CC.4
....................          }  
....................        } 
....................         
....................        if(--UnderTimeCount <=0) 
0270:  DEC     084A
0272:  MOV     84A,W4
0274:  CP      W4,#0
0276:  BRA     GT,29A
....................        { 
....................          UnderTimeCount = 0; 
0278:  CLR     84A
....................          output_low(Under_Rly); 
027A:  BCLR.B  2C8.6
027C:  BCLR.B  2CC.6
....................          output_low(Over_Rly);  
027E:  BCLR.B  2C8.7
0280:  BCLR.B  2CC.7
....................          State = State_Under; 
0282:  MOV.B   #2,W0L
0284:  MOV.B   W0L,845
....................          FlashLEDUnder = false; 
0286:  BCLR.B  802.0
....................          output_high(LED_Under);  
0288:  BCLR.B  2C8.4
028A:  BSET.B  2CC.4
....................          output_low(LED_Over);  
028C:  BCLR.B  2C8.0
028E:  BCLR.B  2CC.0
....................           
....................          output_low(PIN_B3); 
0290:  BCLR.B  2C8.3
0292:  BCLR.B  2CC.3
....................           
....................          if(UnderResTimeCount ==0)  
0294:  CP0     846
0296:  BRA     NZ,29A
....................          { 
....................             TIMER_Flag = 0; 
0298:  CLR.B   868
....................          } 
....................        } 
....................      } 
....................       
....................      if(UnderResTimeCount) 
029A:  CP0     846
029C:  BRA     Z,2F4
....................      { 
....................        if(flash_LED_Under >=200) 
029E:  MOV     802,W4
02A0:  LSR     W4,#8,W4
02A2:  MOV     #C8,W3
02A4:  CP.B    W3L,W4L
02A6:  BRA     GTU,2C0
....................        { 
....................          if(toggle_pin_under==1) 
02A8:  MOV     804,W4
02AA:  LSR     W4,#8,W4
02AC:  CP.B    W4L,#1
02AE:  BRA     NZ,2B8
....................          { 
....................             toggle_pin_under =0; 
02B0:  CLR.B   805
....................             output_high(LED_Over);  
02B2:  BCLR.B  2C8.0
02B4:  BSET.B  2CC.0
....................          } 
....................          else 
02B6:  BRA     2C0
....................          { 
....................             toggle_pin_under =1; 
02B8:  MOV.B   #1,W0L
02BA:  MOV.B   W0L,805
....................             output_low(LED_Over); 
02BC:  BCLR.B  2C8.0
02BE:  BCLR.B  2CC.0
....................          } 
....................        }    
....................        if(--UnderResTimeCount <=0) 
02C0:  DEC     0846
02C2:  MOV     846,W4
02C4:  CP      W4,#0
02C6:  BRA     GT,2F4
....................        { 
....................          UnderResTimeCount = 0; 
02C8:  CLR     846
....................          output_high(Under_Rly); 
02CA:  BCLR.B  2C8.6
02CC:  BSET.B  2CC.6
....................          output_high(Over_Rly);  
02CE:  BCLR.B  2C8.7
02D0:  BSET.B  2CC.7
....................          if(State == State_PreUnderRes) 
02D2:  MOV     844,W4
02D4:  LSR     W4,#8,W4
02D6:  CP.B    W4L,#3
02D8:  BRA     NZ,2DC
....................          { 
....................             State = State_nor; 
02DA:  CLR.B   845
....................          } 
....................          FlashLEDUnder = false; 
02DC:  BCLR.B  802.0
....................          output_low(LED_Under); 
02DE:  BCLR.B  2C8.4
02E0:  BCLR.B  2CC.4
....................          output_high(LED_Over);  
02E2:  BCLR.B  2C8.0
02E4:  BSET.B  2CC.0
....................          if((UnderTimeCount ==0) && (OverTimeCount ==0)&& (OverResTimeCount ==0)) 
02E6:  CP0     84A
02E8:  BRA     NZ,2F4
02EA:  CP0     84C
02EC:  BRA     NZ,2F4
02EE:  CP0     848
02F0:  BRA     NZ,2F4
....................          { 
....................             TIMER_Flag = 0; 
02F2:  CLR.B   868
....................          } 
....................        } 
....................      }  
....................      if(flash_LED_Under >=200) 
02F4:  MOV     802,W4
02F6:  LSR     W4,#8,W4
02F8:  MOV     #C8,W3
02FA:  CP.B    W3L,W4L
02FC:  BRA     GTU,300
....................      { 
....................         flash_LED_Under =0; 
02FE:  CLR.B   803
....................      } 
....................      if(flash_LED_Over >=200) 
0300:  MOV     804,W4
0302:  MOV     #C8,W3
0304:  CP.B    W3L,W4L
0306:  BRA     GTU,30A
....................      { 
....................         flash_LED_Over =0; 
0308:  CLR.B   804
....................      }   
....................    } 
.................... } 
.................... //////////////////////////////////////////////////// 
030A:  BCLR.B  85.0
030C:  MOV     #1A,W0
030E:  REPEAT  #C
0310:  MOV     [--W15],[W0--]
0312:  MOV     [--W15],W0
0314:  POP     36
0316:  POP     42
0318:  RETFIE  
.................... #int_TIMER2 
.................... void TIMER2_isr(void)//5ms interrupt     
.................... {     
*
05C6:  PUSH    42
05C8:  PUSH    36
05CA:  MOV     W0,[W15++]
05CC:  MOV     #2,W0
05CE:  REPEAT  #C
05D0:  MOV     [W0++],[W15++]
....................    SegmentDisplay(); 
05D2:  CALL    346
....................    if(--flash_dot <=0)flash_dot =40; 
05D6:  DEC.B   0807
05D8:  CP0.B   807
05DA:  BRA     NZ,5E0
05DC:  MOV.B   #28,W0L
05DE:  MOV.B   W0L,807
....................     
....................    if(ReadI2CCount ) 
05E0:  CP0.B   82D
05E2:  BRA     Z,5EC
....................    { 
....................       if(--ReadI2CCount ==0) 
05E4:  DEC.B   082D
05E6:  CP0.B   82D
05E8:  BRA     NZ,5EC
....................       { 
....................          ReadI2CCount =0; 
05EA:  CLR.B   82D
....................       } 
....................    } 
....................    if(StartMeasureCount) 
05EC:  CP0     866
05EE:  BRA     Z,602
....................    { 
....................       if(--StartMeasureCount<=0) 
05F0:  DEC     0866
05F2:  MOV     866,W4
05F4:  CP      W4,#0
05F6:  BRA     GT,602
....................       { 
....................          StartMeasureCount = 0; 
05F8:  CLR     866
....................          UnderResTimeCount=0; 
05FA:  CLR     846
....................          OverResTimeCount=0; 
05FC:  CLR     848
....................          UnderTimeCount=0; 
05FE:  CLR     84A
....................          OverTimeCount =0; 
0600:  CLR     84C
....................       } 
....................    }  
.................... } 
.................... /////////////////////////////////////////////////////// 
0602:  BCLR.B  84.7
0604:  MOV     #1A,W0
0606:  REPEAT  #C
0608:  MOV     [--W15],[W0--]
060A:  MOV     [--W15],W0
060C:  POP     36
060E:  POP     42
0610:  RETFIE  
.................... void main() 
.................... { 
*
18D6:  MOV     #4444,W0
18D8:  MOV     W0,A6
18DA:  BSET.B  81.7
18DC:  CLR     744
18DE:  BCLR.B  802.0
18E0:  BCLR.B  802.1
18E2:  CLR.B   803
18E4:  CLR.B   804
18E6:  CLR.B   805
18E8:  CLR.B   806
18EA:  BCLR.B  802.2
18EC:  CLR.B   829
18EE:  CLR.B   82A
18F0:  CLR.B   82B
18F2:  MOV.B   #1,W0L
18F4:  MOV.B   W0L,82C
18F6:  CLR.B   82D
18F8:  BSET.B  802.3
18FA:  BSET.B  802.4
18FC:  BSET.B  802.5
18FE:  CLR     832
1900:  CLR     834
1902:  CLR     836
1904:  CLR     838
1906:  MOV     #4000,W4
1908:  MOV     W4,83A
190A:  MOV     #461C,W4
190C:  MOV     W4,83C
190E:  CLR     83E
1910:  MOV     #442A,W4
1912:  MOV     W4,840
1914:  CLR.B   844
1916:  CLR.B   845
1918:  CLR     846
191A:  CLR     848
191C:  CLR     84A
191E:  CLR     84C
1920:  MOV     #258,W4
1922:  MOV     W4,866
1924:  CLR.B   868
1926:  CLR.B   869
1928:  MOV     #7,W4
192A:  MOV     W4,86C
192C:  SETM    32C
192E:  SETM    32A
1930:  MOV     #1780,W15
1932:  MOV     #17FF,W0
1934:  MOV     W0,20
1936:  NOP     
....................    setup_timer2(TMR_INTERNAL |TMR_DIV_BY_8,0x09C3);//5ms interrupt @ 4(8) Mhz Internals RC (Value in OCR) 
*
1940:  CLR     110
1942:  MOV     #9C3,W4
1944:  MOV     W4,10C
1946:  MOV     #A010,W4
1948:  MOV     W4,110
....................    setup_timer3(TMR_INTERNAL |TMR_DIV_BY_1,0x0F9F);//1ms interrupt @ 4(8) Mhz 
194A:  CLR     112
194C:  MOV     #F9F,W4
194E:  MOV     W4,10E
1950:  MOV     #A000,W4
1952:  MOV     W4,112
....................    enable_interrupts(INT_TIMER3);     
1954:  BSET.B  95.0
....................    RESTART_CAUSE(RESTART_BROWNOUT|RESTART_POWER_UP|RESTART_WATCHDOG); //jj 9/7/63   
1956:  MOV     740,W0
1958:  AND     W0,#5,W0
195A:  MOV     #FFFA,W0
195C:  AND     740
195E:  CP0     W0
....................    enable_interrupts(INT_TIMER2); 
1960:  BSET.B  94.7
....................    enable_interrupts(INTR_GLOBAL);    
1962:  CLR     42
....................    SET_TRIS_B( 0b1110000000001000); 
1964:  MOV     #E008,W4
1966:  MOV     W4,2C8
....................    output_float(BT_DW);   //Set  as Input Pin 
1968:  BSET.B  2C9.5
....................    output_float(BT_UP);   //Set  as Input Pin 
196A:  BSET.B  2C9.6
....................    output_float(BT_SET);   //Set  as Input Pin 
196C:  BSET.B  2C9.7
....................     
....................    output_low(EXP_OUT_DO); 
196E:  BCLR.B  2C9.4
1970:  BCLR.B  2CD.4
....................    output_low(EXP_OUT_CLOCK); 
1972:  BCLR.B  2C9.3
1974:  BCLR.B  2CD.3
....................    output_low(EXP_OUT_ENABLE); 
1976:  BCLR.B  2C9.2
1978:  BCLR.B  2CD.2
....................        
....................    output_low(PIN_B3); 
197A:  BCLR.B  2C8.3
197C:  BCLR.B  2CC.3
....................  
....................    delay_ms(50); 
197E:  MOV     #32,W0
1980:  CALL    612
....................     
....................    Soft_adc_init();         
1984:  CALL    6C6
....................     
....................    UnderValue = read_ext_eeprom(UnderSet_addr);if(UnderValue < MIN_VOLT || UnderValue > NORMAL_VOLT-1) UnderValue = 15; 
1988:  CLR.B   876
198A:  CALL    7F4
198E:  CLR.B   1
1990:  CALL    87A
1994:  MOV     W0,856
1996:  MOV     W1,858
1998:  MOV     856,W0
199A:  MOV     858,W1
199C:  MOV     #0,W2
199E:  MOV     #4170,W3
19A0:  CALL    8B4
19A4:  BRA     C,19B4
19A6:  MOV     #0,W0
19A8:  MOV     #41B8,W1
19AA:  MOV     856,W2
19AC:  MOV     858,W3
19AE:  CALL    8B4
19B2:  BRA     NC,19BA
19B4:  CLR     856
19B6:  MOV     #4170,W4
19B8:  MOV     W4,858
....................    UnderResValue = read_ext_eeprom(UnderResSet_addr);if(UnderResValue < UnderValue + 1 || UnderResValue > NORMAL_VOLT) UnderResValue = UnderValue+5; 
19BA:  MOV.B   #2,W0L
19BC:  MOV.B   W0L,876
19BE:  CALL    7F4
19C2:  CLR.B   1
19C4:  CALL    87A
19C8:  MOV     W0,85E
19CA:  MOV     W1,860
19CC:  BCLR.B  43.0
19CE:  MOV     856,W0
19D0:  MOV     858,W1
19D2:  MOV     #0,W2
19D4:  MOV     #3F80,W3
19D6:  CALL    91C
19DA:  MOV     W0,W2
19DC:  MOV     W1,W3
19DE:  MOV     85E,W0
19E0:  MOV     860,W1
19E2:  CALL    8B4
19E6:  BRA     C,19F6
19E8:  MOV     #0,W0
19EA:  MOV     #41C0,W1
19EC:  MOV     85E,W2
19EE:  MOV     860,W3
19F0:  CALL    8B4
19F4:  BRA     NC,1A08
19F6:  BCLR.B  43.0
19F8:  MOV     856,W0
19FA:  MOV     858,W1
19FC:  MOV     #0,W2
19FE:  MOV     #40A0,W3
1A00:  CALL    91C
1A04:  MOV     W0,85E
1A06:  MOV     W1,860
....................     
....................    UnderTimSetValue = read_ext_eeprom(UnderTimSet_addr);if(UnderTimSetValue < 0 || UnderTimSetValue > 60) UnderTimSetValue = 5; 
1A08:  MOV.B   #4,W0L
1A0A:  MOV.B   W0L,876
1A0C:  CALL    7F4
1A10:  MOV.B   W0L,852
1A12:  CLR.B   853
1A14:  MOV     852,W4
1A16:  CP      W4,#0
1A18:  BRA     LT,1A22
1A1A:  MOV     852,W4
1A1C:  MOV     #3C,W3
1A1E:  CP      W3,W4
1A20:  BRA     GE,1A26
1A22:  MOV     #5,W4
1A24:  MOV     W4,852
....................    UnderResTimSetValue = read_ext_eeprom(UnderResTimSet_addr);if(UnderResTimSetValue < 0 || UnderResTimSetValue > 60) UnderResTimSetValue = 5; 
1A26:  MOV.B   #6,W0L
1A28:  MOV.B   W0L,876
1A2A:  CALL    7F4
1A2E:  MOV.B   W0L,850
1A30:  CLR.B   851
1A32:  MOV     850,W4
1A34:  CP      W4,#0
1A36:  BRA     LT,1A40
1A38:  MOV     850,W4
1A3A:  MOV     #3C,W3
1A3C:  CP      W3,W4
1A3E:  BRA     GE,1A44
1A40:  MOV     #5,W4
1A42:  MOV     W4,850
....................     
....................    delay_ms(500); 
1A44:  MOV     #1F4,W0
1A46:  CALL    612
....................    int8 i; 
....................    for(i=0;i<=10;i++) 
1A4A:  CLR.B   872
1A4C:  MOV     872,W4
1A4E:  CP.B    W4L,#A
1A50:  BRA     GT,1AFE
....................    { 
....................       real_data = Soft_read_adc_mcp();  
1A52:  CALL    B42
1A56:  MOV     W0,830
....................       vout = (real_data * 2.048) / 32767.0; // see text 
1A58:  MOV     830,W5
1A5A:  MOV     W5,W0
1A5C:  CLR     W3
1A5E:  BTSC    W0.F
1A60:  SETM    W3
1A62:  MOV     W3,W1
1A64:  MOV     W3,W2
1A66:  CALL    B80
1A6A:  MOV     W5,[W15++]
1A6C:  MOV     #A9FC,W4
1A6E:  MOV     #D2F1,W5
1A70:  MOV     #624D,W6
1A72:  MOV     #4000,W7
1A74:  CALL    BE4
1A78:  MOV     [--W15],W5
1A7A:  MOV     W0,W5
1A7C:  MOV     W1,W6
1A7E:  MOV     W2,W7
1A80:  MOV     W3,W8
1A82:  MOV     W5,[W15++]
1A84:  MOV     W6,[W15++]
1A86:  MOV     W7,[W15++]
1A88:  MOV     W5,W0
1A8A:  MOV     W6,W1
1A8C:  MOV     W7,W2
1A8E:  MOV     W8,W3
1A90:  MOV     #0,W4
1A92:  MOV     #0,W5
1A94:  MOV     #FFC0,W6
1A96:  MOV     #40DF,W7
1A98:  CALL    CF2
1A9C:  MOV     [--W15],W7
1A9E:  MOV     [--W15],W6
1AA0:  MOV     [--W15],W5
1AA2:  CALL    DFA
1AA6:  MOV     W1,832
1AA8:  MOV     W2,834
....................       vin = vout / (R2/(R1+R2)); 
1AAA:  BCLR.B  43.0
1AAC:  MOV     83A,W0
1AAE:  MOV     83C,W1
1AB0:  MOV     83E,W2
1AB2:  MOV     840,W3
1AB4:  CALL    91C
1AB8:  MOV     W0,W2
1ABA:  MOV     W1,W3
1ABC:  MOV     83E,W0
1ABE:  MOV     840,W1
1AC0:  CALL    E3E
1AC4:  MOV     W0,W2
1AC6:  MOV     W1,W3
1AC8:  MOV     832,W0
1ACA:  MOV     834,W1
1ACC:  CALL    E3E
1AD0:  MOV     W0,836
1AD2:  MOV     W1,838
....................       DC_V =(int16)vin;   
1AD4:  PUSH    42
1AD6:  SETM.B  42
1AD8:  MOV     836,W0
1ADA:  MOV     838,W1
1ADC:  CALL    31A
1AE0:  POP     42
1AE2:  MOV     W0,808
....................        
....................       DC_Average[i] = DC_V; 
1AE4:  MOV.B   872,W0L
1AE6:  SE      W0,W0
1AE8:  MOV     W0,W4
1AEA:  MUL.UU  W4,#2,W0
1AEC:  MOV     #80C,W4
1AEE:  ADD     W0,W4,W5
1AF0:  MOV     808,W4
1AF2:  MOV     W4,[W5+#0]
....................        
....................       delay_ms(20); 
1AF4:  MOV     #14,W0
1AF6:  CALL    612
....................     
....................    } 
1AFA:  INC.B   0872
1AFC:  BRA     1A4C
....................    DC_V = DC_Average[0]; 
1AFE:  PUSH    80C
1B00:  POP     808
....................    DC_V = DC_V + DC_Average[1]; 
1B02:  MOV     808,W0
1B04:  ADD     80E,W0
1B06:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[2]; 
1B08:  MOV     808,W0
1B0A:  ADD     810,W0
1B0C:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[3]; 
1B0E:  MOV     808,W0
1B10:  ADD     812,W0
1B12:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[4]; 
1B14:  MOV     808,W0
1B16:  ADD     814,W0
1B18:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[5]; 
1B1A:  MOV     808,W0
1B1C:  ADD     816,W0
1B1E:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[6]; 
1B20:  MOV     808,W0
1B22:  ADD     818,W0
1B24:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[7]; 
1B26:  MOV     808,W0
1B28:  ADD     81A,W0
1B2A:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[8]; 
1B2C:  MOV     808,W0
1B2E:  ADD     81C,W0
1B30:  MOV     W0,808
....................    DC_V = DC_V + DC_Average[9]; 
1B32:  MOV     808,W0
1B34:  ADD     81E,W0
1B36:  MOV     W0,808
....................    DC_V = DC_V/10; 
1B38:  MOV     808,W4
1B3A:  MOV     #A,W3
1B3C:  REPEAT  #11
1B3E:  DIV.U   W4,W3
1B40:  MOV     W0,808
....................     
....................    if(DC_V <= UnderValue) 
1B42:  MOV     808,W0
1B44:  CALL    87A
1B48:  MOV     856,W2
1B4A:  MOV     858,W3
1B4C:  CALL    8B4
1B50:  BRA     C,1B54
1B52:  BRA     NZ,1B6C
....................    { 
....................       output_low(Under_Rly);//on rly 
1B54:  BCLR.B  2C8.6
1B56:  BCLR.B  2CC.6
....................       output_low(Over_Rly);//on rly 
1B58:  BCLR.B  2C8.7
1B5A:  BCLR.B  2CC.7
....................       State = State_Under; 
1B5C:  MOV.B   #2,W0L
1B5E:  MOV.B   W0L,845
....................       FlashLEDUnder = false;   
1B60:  BCLR.B  802.0
....................       output_high(LED_Under);//on led 
1B62:  BCLR.B  2C8.4
1B64:  BSET.B  2CC.4
....................       output_low(LED_Over); 
1B66:  BCLR.B  2C8.0
1B68:  BCLR.B  2CC.0
....................    } 
....................    else 
1B6A:  BRA     1B82
....................    { 
....................       output_high(Under_Rly);//on rly 
1B6C:  BCLR.B  2C8.6
1B6E:  BSET.B  2CC.6
....................       output_high(Over_Rly);//on rly 
1B70:  BCLR.B  2C8.7
1B72:  BSET.B  2CC.7
....................       output_low(LED_Under);//off rly 
1B74:  BCLR.B  2C8.4
1B76:  BCLR.B  2CC.4
....................       output_high(LED_Over);//off rly 
1B78:  BCLR.B  2C8.0
1B7A:  BSET.B  2CC.0
....................       UnderTimeCount = 0; 
1B7C:  CLR     84A
....................       State = State_nor; 
1B7E:  CLR.B   845
....................       FlashLEDUnder = false; //on led   
1B80:  BCLR.B  802.0
....................    } 
....................       
....................    setup_wdt(WDT_ON); 
1B82:  BSET.B  740.5
....................    setup_timer1(TMR_INTERNAL|TMR_DIV_BY_8); 
1B84:  CLR     104
1B86:  SETM    102
1B88:  MOV     #A010,W4
1B8A:  MOV     W4,104
....................       
....................    unsigned int16 Count_Healty =7;//7 612 us  
1B8C:  MOV     #7,W4
1B8E:  MOV     W4,874
....................    while(1) 
....................    {   
....................       Count_Healty++; 
1B90:  INC     0874
....................       output_toggle(PIN_A4); //5.6 uSec perloop 
1B92:  BCLR.B  2C0.4
1B94:  BTG.B   2C4.4
....................       restart_wdt(); 
1B96:  CLRWDT  
....................          
....................       if(Count_Healty %1500 ==0 )// 30 mS. 
1B98:  MOV     874,W4
1B9A:  MOV     #5DC,W3
1B9C:  REPEAT  #11
1B9E:  DIV.U   W4,W3
1BA0:  MOV     W1,W5
1BA2:  CP0     W5
1BA4:  BRA     NZ,1BAA
....................       {         
....................          buttonRead(); 
1BA6:  CALL    11DC
....................       } 
....................        
....................       if(Count_Healty %1000 ==0 ) //20 mS. 
1BAA:  MOV     874,W4
1BAC:  MOV     #3E8,W3
1BAE:  REPEAT  #11
1BB0:  DIV.U   W4,W3
1BB2:  MOV     W1,W5
1BB4:  CP0     W5
1BB6:  BRA     NZ,1BBC
....................       {         
....................          Read_VDC();//Time for Read VDC is 62 ms.  
1BB8:  CALL    15F2
....................       } 
....................        
....................       if(Count_Healty %32750 ==0 ) 
1BBC:  MOV     874,W4
1BBE:  MOV     #7FEE,W3
1BC0:  REPEAT  #11
1BC2:  DIV.U   W4,W3
1BC4:  MOV     W1,W5
1BC6:  CP0     W5
1BC8:  BRA     NZ,1BDC
....................       {           
....................          output_toggle(LED_Healty); 
1BCA:  BCLR.B  2C8.5
1BCC:  BTG.B   2CC.5
....................          Count_Healty =1; 
1BCE:  MOV     #1,W4
1BD0:  MOV     W4,874
....................           
....................          // Re-initial if MCP3425 Hang 
....................          if(DC_V < 10 ) 
1BD2:  MOV     808,W4
1BD4:  CP      W4,#A
1BD6:  BRA     C,1BDC
....................          { 
....................             Soft_adc_init(); 
1BD8:  CALL    6C6
....................          } 
....................       } 
....................    
....................       //*********  Menu Count ***************_/ 
....................       if(menuCount) 
1BDC:  CP0     824
1BDE:  BRA     NZ,1BE4
1BE0:  CP0     826
1BE2:  BRA     Z,1BFA
....................       {  
....................          if(--menuCount ==0) 
1BE4:  DEC     0824
1BE6:  BTSS.B  42.0
1BE8:  DEC     0826
1BEA:  CP0     824
1BEC:  BRA     NZ,1BFA
1BEE:  CP0     826
1BF0:  BRA     NZ,1BFA
....................          { 
....................            menuCount =0; 
1BF2:  CLR     824
1BF4:  CLR     826
....................            mode = Nor_UnOly;  
1BF6:  CLR.B   844
....................            set_mode = false; 
1BF8:  BCLR.B  802.2
....................          } 
....................          
....................       } 
....................    } 
1BFA:  BRA     1B90
....................    
.................... } 
1BFC:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 1FEF   NOJTAG PROTECT NOWRT NODEBUG ICSP1 WDT WINDIS WPRES32 WPOSTS16
          H: 0000  
   Word  2L: AAF7   IOL1WAY IESO PR NOCKSFSM NOOSCIO NOPR I2C1SELD
          H: 0000  
